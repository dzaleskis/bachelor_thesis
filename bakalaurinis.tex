\documentclass{VUMIFInfBakalaurinis}
\usepackage{algorithmicx}
\usepackage{algorithm}
\usepackage{algpseudocode}
\usepackage{amsfonts}
\usepackage{amsmath}
\usepackage{bm}
\usepackage{caption}
\usepackage{color}
\usepackage{float}
\usepackage{graphicx}
% \usepackage{hyperref}  % Nuorodų aktyvavimas
\usepackage{listings}
\usepackage{subfig}
\usepackage{url}
\usepackage{wrapfig}
\usepackage{booktabs}
\usepackage[table,xcdraw]{xcolor}

\algnewcommand\algorithmicforeach{\textbf{foreach}}
\algdef{S}[FOR]{ForEach}[1]{\algorithmicforeach\ #1\ \algorithmicdo}

\definecolor{eclipseStrings}{RGB}{127,0,85}
\definecolor{eclipseKeywords}{RGB}{42,0,255}
\colorlet{numb}{magenta!60!black}


\lstset{
  basicstyle=\normalfont\ttfamily,
  commentstyle=\color{eclipseKeywords}, % style of comment
  stringstyle=\color{eclipseStrings}, % style of strings
  backgroundcolor=\color{white},
  showstringspaces=false,
  breaklines=true,
  frame=lines,
}

\lstdefinelanguage{json}{
    string=[s]{"}{"},
    literate=
        *{0}{{{\color{numb}0}}}{1}
         {1}{{{\color{numb}1}}}{1}
         {2}{{{\color{numb}2}}}{1}
         {3}{{{\color{numb}3}}}{1}
         {4}{{{\color{numb}4}}}{1}
         {5}{{{\color{numb}5}}}{1}
         {6}{{{\color{numb}6}}}{1}
         {7}{{{\color{numb}7}}}{1}
         {8}{{{\color{numb}8}}}{1}
         {9}{{{\color{numb}9}}}{1}
}

% Titulinio aprašas
\university{Vilniaus universitetas}
\faculty{Matematikos ir informatikos fakultetas}
\institute{Informatikos institutas}
\department{Informatikos katedra}
\papertype{Baigiamasis bakalauro darbas}
\title{Rikiavimo tobulinimas genetiniais algoritmais}
\titleineng{Improving Sorting with Genetic Algorithms}
\status{4 kurso 2 grupės studentas}
\author{Deividas Zaleskis}
\supervisor{Irmantas Radavičius}
% FIXME - nesamone
\reviewer{doc. dr. Vardauskas Pavardauskas}
\date{Vilnius \\ \the\year}

\bibliography{bibliografija} 

\begin{document}
\maketitle

\tableofcontents

\sectionnonum{Sąvokų apibrėžimai}
% Sutartinių ženklų, simbolių, vienetų ir terminų sutrumpinimų sąrašas (jeigu
% ženklų, simbolių, vienetų ir terminų bendras skaičius didesnis nei 10 ir
% kiekvienas iš jų tekste kartojasi daugiau nei 3 kartus).

Šelo algoritmas
GA
OS
WSL

\sectionnonum{Įvadas}

Duomenų rikiavimas yra vienas aktyviausiai tiriamų uždavinių informatikos moksle.
Iš dalies tai lemia rikiavimo uždavinio prieinamumas ir analizės paprastumas.
Formaliai rikiavimo uždavinys formuluojamas taip:
duotai baigtinei palyginamų elementų sekai $S = (s_1, s_2, ..., s_n)$ pateikti tokį
kėlinį, kad duotosios sekos elementai būtų išdėstyti monotonine (didėjančia arba mažėjančia) tvarka.
Kadangi rikiavimo uždavinio sąlyga yra gana paprasta, tai suteikia didelę galimų implementacijų įvairovę.
Todėl nauji rikiavimo algoritmai ir įvairūs patobulinimai egzistuojantiems algoritmams yra kuriami ir dabar.

Rikiavimo uždavinys yra fundamentalus, kadangi rikiavimas padeda pagrindą efektyviam kitų uždavinių sprendimui.
Kaip to pavyzdį galima pateikti dvejetainės paieškos algoritmą, kurio prielaida,
jog duomenys yra išrikiuoti, leidžia sumažinti paieškos laiko sudėtingumą iki $O(log\,n)$.
Rikiavimas taip pat svarbus duomenų normalizavimui bei pateikimui žmonėms lengvai suprantamu formatu.
Kadangi duomenų rikiavimas yra fundamentalus uždavinys, net ir nežymūs patobulinimai žvelgiant bendrai
gali atnešti didelę naudą.

Rikiavimo uždaviniui spręsti egzistuoja labai įvairių algoritmų.
Plačiausiai žinomi yra klasikiniai rikiavimo algoritmai: rikiavimas sąlaja (angl. merge sort), rikiavimas įterpimu (angl. insertion sort) ir greitojo rikiavimo algoritmas (angl. quicksort).
Tiesa, šie algoritmai turi įvairių trukūmų:
rikiavimas sąlaja dažnai veikia lėčiau nei nestabilūs algoritmai ir naudoja $O(n)$ papildomos atminties, rikiavimas įterpimu yra efektyvus tik kai rikiuojamų duomenų dydis yra mažas, o
greitojo rikiavimo algoritmas blogiausiu atveju turi $O(n^2)$ laiko sudėtingumą.
Todėl šiuo metu praktikoje plačiausiai naudojami hibridiniai rikiavimo algoritmai, kurie apjungia kelis klasikinius algoritmus į vieną panaudodami jų geriausias savybes.
Pavyzdžiui, C++ programavimo kalbos standartinėje bibliotekoje naudojamas introspektyvaus rikiavimo (angl. introsort) algoritmas įprastai naudoja greitojo rikiavimo algoritmą,
pasiekus tam tikrą rekursijos gylį yra naudojamas rikiavimas krūva (angl. heapsort) siekiant išvengti $O(n^2)$ laiko sudėtingumo,
o kai rikiuojamų duomenų dydis yra pakankamai mažas, pasitelkiamas rikiavimas įterpimu, kadangi su mažais duomenų dydžiais jis yra efektyvesnis.
Apibendrinant, pasitelkiant įvairius rikiavimo algoritmus ir jų unikalias savybes yra įmanoma rikiavimo uždavinį spręsti efektyviau.

Vienas iš teorine prasme įdomiausių klasikinių algoritmų yra Šelo rikiavimo algoritmas.
Šelo algoritmą galima laikyti rikiavimo įterpimu optimizacija, kadangi atliekant rikiavimą yra lyginami ne tik gretimi elementai,
kas leidžia kai kuriuos elementus perkelti į galutinę poziciją atliekant mažiau operacijų.
Pagrindinė algoritmo idėja - išskaidyti rikiuojamą seką $S$ į posekius $S_1, S_2, ..., S_n$, kur
$S_i = (s_i, s_{i+h}, s_{i+2h}, ...)$ ir atskirai išrikiuoti kiekvieną posekį $S_i$.
Įprastai tarpų rinkinys, kuriuo remiantis formuojami rikiuojami posekiai, vadinamas tarpų seka.
Šelo algoritmo efektyvumas priklauso nuo pasirinktos tarpų sekos, todėl bendra teorinė šio algoritmo analizė yra labai sudėtinga.
Taip pat reikia pastebėti, jog praktikoje efektyviausi yra eksperimentiškai gauti Šelo algoritmo variantai \cite{ciura2001best,tokuda1992}.

Literatūroje galima rasti darbų \cite{roos2002genetic,simpson1999faster}, kuriuose genetiniai algoritmai yra taikomi naujų Šelo algoritmo tarpų sekų radimui.
Simpson-Yachavaram darbe daugiausia dėmesio skiriama atliekamiems palyginimams, teigiama, jog gautos tarpų sekos atlieka mažiausiai palyginimo operacijų,
tačiau jos yra lyginamos tik su Sedgewick ir Incerpi-Sedgewick tarpų sekomis.
Tačiau šiuo metu yra laikoma, jog vidutiniškai atliekamų palyginimų atžvilgiu optimaliausia yra Ciura \cite{ciura2001best} tarpų seka.
Kursinio darbo metu buvo atliktas Ciura ir Simpson-Yachavaram tarpų sekų tarpusavio palyginimas vidutiniškai atliekamų priskyrimų atžvilgiu, gauti rezultatai tam neprieštaravo.
Roos et al. darbe daugiausia dėmesio skiriama veikimo laikui, teigiama, jog gauta tarpų seka veikia greičiau nei kitos tirtos tarpų sekos, tačiau
pateikiamuose rezultatuose ji lyginama tik su Simpson-Yachavaram tarpų seka, tiriami tik keli duomenų dydžiai.
Kursinio darbo metu buvo atliktas platesnio masto Roos et al. ir kitų tarpų sekų tarpusavio palyginimas vidutinio veikimo laiko atžvilgiu,
pagal gautus rezultatus Roos et al. sekos veikimo laikas buvo mažiausias, tačiau ji taip pat atliko žymiai daugiau palyginimo ir priskyrimo operacijų nei kitos tirtos tarpų sekos.
Nepaisant aukščiau aprašytų darbų trūkumų, juose gauti rezultatai rodo, jog genetinių algoritmų taikymas Šelo algoritmo variantų konstravimui
yra prasmingas ir gali duoti reikšmingų rezultatų.

Viena iš pagrindinių problemų konstruojant rikiavimo algoritmą yra pusiausvyros tarp atliekamų operacijų ir veikimo laiko išlaikymas.
Algoritmas, kuris atlieka labai mažai operacijų, tačiau veikia lėtai, yra įdomus tik teorine prasme ir sunkiai panaudojamas praktikoje.
Tas pats galioja ir algoritmams, kurie prioritetizuoja tik veikimo laiką, tačiau atlieka labai daug operacijų, kadangi 
tai apsunkina sudėtingesnių duomenų tipų rikiavimą ir apriboja duoto algoritmo panaudojamumą.
Todėl prasmingiausia būtų ieškoti naujų Šelo algoritmo variantų pasitelkiant tokį metodą, kuris išlaikytų pusiausvyrą tarp veikimo laiko ir atliekamų operacijų.
Kursiniame projekte buvo atliktas tyrimas, kuriame pasitelkiant vienkriterinį genetinį algoritmą buvo konstruojami
Šelo algoritmo variantai.
Siekiant išlaikyti balansą tarp skirtingų kriterijų, buvo pasitelktas svorinės sumos metodas, tačiau
tyrimo metu buvo pastebėtas jo ribotas efektyvumas ir svorių teikimo skirtingiems kriterijams nepagrįstumas.
Atsižvelgiant į kursiniame projekte atlikto tyrimo trūkumus, šiame darbe pasirinkta naudoti daugiakriterinį genetinį algoritmą, kuris
padėtų sukonstruoti algoritmą išlaikantį pusiausvyrą tarp atliekamų operacijų ir veikimo laiko.

\medskip

Keliama tokia \textbf{hipotezė}:

\textit{Pasitelkiant genetinius algoritmus įmanoma sukonstruoti efektyvius Šelo algoritmo variantus,
kurių vidutinis veikimo laikas būtų mažesnis nei šiuo metu žinomų variantų.}

\medskip

Siekiant patikrinti iškeltą hipotezę, reikia atlikti šiuos \textbf{uždavinius}:
\begin{itemize}
    \item Išanalizuoti Šelo algoritmą ir jo variantus remiantis literatūra ir eksperimentiškai gautais duomenimis;
    \item Nustatyti kriterijus Šelo algoritmo variantų efektyvumui įvertinti;
    \item Realizuoti genetinį algoritmą Šelo algoritmo variantų generavimui;
    \item Pasitelkiant realizuotą genetinį algoritmą sugeneruoti Šelo algoritmo variantus;
    \item Eksperimentiškai palyginti sugeneruotų ir pateiktų literatūroje Šelo algoritmo variantų efektyvumą.
  \end{itemize}

\medskip

Šiame darbe atlikta:
\begin{itemize}
    \item kol kas nieko
\end{itemize}

\medskip

Darbas remiasi tokiomis prielaidomis:
\begin{itemize}
    \item Atliekant Šelo algoritmo variantų generavimą ir tarpusavio palyginimą rikiuojamų duomenų palyginimo ir priskyrimo sudėtingumas laiko atžvilgiu yra $O(1)$;
    \item Atliekant Šelo algoritmo variantų tarpusavio palyginimą yra pakankama aprėpti geriausiai žinomus variantus
        (visų literatūroje pateiktų variantų tarpusavio palyginimas reikalautų atskiro tyrimo);
    \item Šelo algoritmo variantų tarpusavio palyginimui pasirinkti duomenų rinkiniai pakankamai tiksliai atspindi dažniausiai praktikoje sutinkamus duomenų rinkinius.
\end{itemize}


\section{Šelo algoritmas}

Šis skyrius sudarytas iš 3 poskyrių.
Pirmame poskyryje remiantis literatūra atliekama Šelo algoritmo analizė.
Antrame poskyryje remiantis literatūra atliekama Šelo algoritmo variantų analizė.
Trečiame poskyryje atliekama eksperimentinė Šelo algoritmo analizė.

\subsection{Šelo algoritmo literatūros analizė}

% gal reiketu daugiau?

Šelo algoritmas yra vienas iš seniausių ir geriausiai žinomų rikiavimo algoritmų.
Šelo algoritmas yra paremtas palyginimu, adaptyvus, nestabilus ir nenaudojantis papildomos atminties.
Yra įrodyta, kad Šelo algoritmo laiko sudėtingumo blogiausiu atveju apatinė riba yra
$\Omega(\frac{n\,log^2\,n}{log\,log\,n^2})$ \cite{plaxton1992}, tad jis nėra asimptotiškai optimalus.
Šio algoritmo laiko sudėtingumo analizė vidutiniu atveju yra labai sudėtinga
ir lieka atvira problema \cite{ciura2001best,Radavičius_Baranauskas_2013}.
Nepaisant sudėtingos analizės, Šelo algoritmas yra nesunkiai įgyvendinamas ir gana lengvai suprantamas.
Tai įrodo ir pseudokodas, pateikiamas \ref{alg:shellsort} algoritme.

\begin{algorithm}[H]
  \caption{Šelo algoritmas}\label{alg:shellsort}
  \begin{algorithmic}[1]
  \ForEach {$h$ \textbf{in} $H$}
    \For {$i\gets h$ \textbf{to} $N-1$}
      \State $j\gets i$
      \State $temp\gets S[i]$
      \While {$j > h$ \textbf{and} $S[j - h] > S[j]$}
        \State $S[j]\gets S[j - h]$
        \State $j\gets j-h$
      \EndWhile
      \State $S[j]\gets temp$
    \EndFor
  \EndFor
  \end{algorithmic}
\end{algorithm}

Reikia pastebėti, jog klasikinis Šelo algoritmas nėra optimizuotas ir tam tikrais atvejais atlieka nereikalingas operacijas.
Jei vykdant vidinį Šelo algoritmo ciklą esamas elementas $S[j]$ nėra mažesnis už elementą $S[j-h]$,
$while$ ciklas kuriame atliekama esminė rikiavimo logika nebus vykdomas, tad du priskyrimai bus atlikti veltui.
Optimizuota Šelo algoritmo versija \cite{Radavičius_Baranauskas_2013} patikrina ar esamas elementas yra mažesnis už elementą $S[j-h]$ ir tik tada vykdo vidinį ciklą.
Tai leidžia sumažinti atliekamų priskyrimų skaičių 40-80\% ir sumažinti veikimo laiką apytiksliai 20\%, lyginant su klasikine implementacija.
Toliau darbe naudojama ir analizuojama tik optimizuota Šelo algoritmo implementacija. 

\begin{algorithm}[H]
    \caption{Optimizuotas Šelo algoritmas}\label{alg:shellsort_optimized}
    \begin{algorithmic}[1]
      \ForEach {$h$ \textbf{in} $H$}
        \For {$i\gets h$ \textbf{to} $N-1$}
          \If {$S[i-h] > S[i]$}
            \State $j\gets i$
            \State $temp\gets S[i]$
            \Repeat
              \State $S[j]\gets S[j - h]$
              \State $j\gets j-h$
            \Until {$j \le h$ or $S[j - h] \le S[j]$}
            \State $S[j]\gets temp$
          \EndIf
        \EndFor
      \EndFor
    \end{algorithmic}
  \end{algorithm}

\subsection{Šelo algoritmo variantų literatūros analizė}

Šelo algoritmas pasižymi variantų gausa.
Šelo algoritmą iš esmės galima laikyti tarpų iteravimu, su kiekvienu iš jų atliekant tam tikro posekio rikiavimą.
Tad norint patobulinti Šelo algoritmą galima keisti tiek posekių formavimą (naudojant kitokią tarpų seką),
tiek posekių rikiavimo logiką.
Šioje darbo dalyje nagrinėsime tuos variantus, kurie nuo originalios versijos skiriasi taikoma posekių rikiavimo logika.

Siekiant supaprastinti skirtingų Šelo algoritmo variantų palyginimą, galima išskirti dvi sudėtines kiekvieno varianto dalis:
visiems variantams bendrą struktūrą ir konkrečiam variantui būdingą posekių rikiavimo logiką.
Šelo algoritmo variantams būdingą struktūrą toliau vadinsime Šelo algoritmo karkasu,
o karkaso viduje atliekamą rikiavimo logiką - perėjimu (angl. pass).
Šelo algoritmo karkaso apibrėžimas pateikiamas pseudokodu \ref{alg:shell_framework} algoritme.
Standartinį Šelo algoritmo taikomą perėjimą toliau vadinsime įterpimo perėjimu.

\begin{algorithm}[H]
  \caption{Šelo algoritmo karkasas}\label{alg:shell_framework}
  \begin{algorithmic}[1]
    \ForEach {$h$ \textbf{in} $H$}
        \State perform pass with gap $h$
    \EndFor
  \end{algorithmic}
\end{algorithm}

Dobosiewicz vienas pirmųjų pastebėjo, jog pasitelkiant
Šelo algoritmo karkasą ir pakeitus rikiavimo logiką (perėjimą) taip pat galima sukonstruoti pakankamai
efektyvų algoritmą \cite{dobosiewicz1980efficient}.
Dobosiewicz taikytas perėjimas yra labai panašus į burbuliuko rikiavimo algoritmo (angl. bubble sort) atliekamas operacijas:
einama iš kairės į dešinę, palyginant ir (jei reikia) sukeičiant elementus vietomis.
Todėl šis perėjimas dažniausiai vadinamas burbuliuko perėjimu (angl. bubble pass) \cite{sedgewick1996analysis}.
Jo pseudokodas pateikiamas \ref{alg:bubble_pass} algoritme.

\begin{algorithm}[H]
  \caption{Burbuliuko perėjimas}\label{alg:bubble_pass}
  \begin{algorithmic}[1]
    \For {$i\gets 0$ \textbf{to} $N-gap-1$}
      \If {$S[i] > S[i+gap]$}
        \State $swap(S[i], S[i+gap])$
      \EndIf
    \EndFor
  \end{algorithmic}
\end{algorithm}

Tiesa, burbuliuko metodą galima nežymiai patobulinti, suteikiant jam daugiau simetrijos ir atliekant perėjimą
tiek iš kairės į dešinę, tiek iš dešinės į kairę.
Tokiu būdu dešinėje esantys elementai greičiau pasieks savo galutinę poziciją.
Šis metodas primena kokteilio purtymą, todėl literatūroje dažnai vadinamas kokteilio rikiavimu (angl. cocktail sort arba shaker sort).
Šio algoritmo taikomą perėjimą, kurį toliau vadinsime supurtymo perėjimu (angl. shake pass), integravus į Šelo algoritmo karkasą
taip pat gaunamas gana įdomus algoritmas \cite{incerpi1986practical}.
Supurtymo perėjimo pseudokodas pateikiamas \ref{alg:shake_pass} algoritme.

\begin{algorithm}[H]
  \caption{Supurtymo perėjimas}\label{alg:shake_pass}
  \begin{algorithmic}[1]
    \For {$i\gets 0$ \textbf{to} $N-gap-1$}
      \If {$S[i] > S[i+gap]$}
        \State $swap(S[i], S[i+gap])$
      \EndIf
    \EndFor

    \For {$i\gets N-gap-1$ \textbf{to} $0$}
      \If {$S[i] > S[i+gap]$}
        \State $swap(S[i], S[i+gap])$
      \EndIf
    \EndFor
  \end{algorithmic}
\end{algorithm}

Dar viena burbuliuko algoritmo modifikacija yra mūrijimo rikiavimas (angl. brick sort) \cite{habermann1972parallel}.
Šio algoritmo perėjimo idėja - išrikiuoti visas nelyginių/lyginių indeksų gretimų elementų poras,
o tada atlikti tą patį visoms lyginių/nelyginių indeksų gretimų elementų poroms.
Šią idėją nesunkiai galima pritaikyti ir Šelo algoritmo karkasui, kintamuoju pakeitus originaliame algoritme taikytą tarpą $1$ \cite{lemke1994performance}.
Šį perėjimą toliau vadinsime mūrijimo perėjimu (angl. brick pass).
Jo pseudokodas yra pateikiamas \ref{alg:brick_pass} algoritme.

\begin{algorithm}[H]
  \caption{Mūrijimo perėjimas}\label{alg:brick_pass}
  \begin{algorithmic}[1]
    \For {$i\gets gap$ \textbf{to} $N-gap-1$ \textbf{step} $2*gap$}
      \If {$S[i] > S[i+gap]$}
        \State $swap(S[i], S[i+gap])$
      \EndIf
    \EndFor

    \For {$i\gets 0$ \textbf{to} $N-gap-1$ \textbf{step} $2*gap$}
      \If {$S[i] > S[i+gap]$}
        \State $swap(S[i], S[i+gap])$
      \EndIf
    \EndFor
  \end{algorithmic}
\end{algorithm}

\subsection{Eksperimentinė Šelo algoritmo analizė}

Norint paruošti greitai veikiantį Šelo algoritmo variantą arba taisykles tokiam algoritmui gauti, vertinga žinoti, kodėl vieni variantai veikia greičiau nei kiti.
Pradėkime nuo to, jog kursiniame darbe ir kursiniame projekte buvo pastebėta, jog Šelo algoritmo variantų atliekamų operacijų skaičius ne visada koreliuoja su veikimo laiku.
Dėl šiuolaikinių kompiuterių veikimo subtilybių algoritmai, kurie atlieka daugiau palyginimo ir priskyrimo operacijų,
kai kuriais atvejais gali veikti greičiau, nei operacijų atžvilgiu optimalesni algoritmai.
Atliekant kursinį darbą ir kursinį projektą buvo pastebėta būtent tai - 
tyrimuose geriausius veikimo laiko rezultatus parodę Šelo algoritmo variantai atliko ženkliai daugiau operacijų, nei atliekamų operacijų operacijų atžvilgiu optimalūs variantai.
Taigi, keliama pradinė hipotezė, jog vien operacijų skaičius neleidžia tinkamai įvertinti kaip Šelo algoritmo variantas veiks praktikoje.

Pirmiausia pastebėsime, jog šiuolaikinių kompiuterių architektūros yra labai sudėtingos, kas dažnu atveju neleidžia iš anksto nustatyti praktinio algoritmo efektyvumo.
Išankstinę teorinę analizę apsunkina įvairios šiuolaikinių kompiuterių architektūrose pasitelkiamos strategijos:
instrukcijų vykdymas ne iš eilės (siekiant pilnai išnaudoti procesoriaus ciklus),
duomenų saugojimas kelių lygių talpykloje (siekiant panaikinti atminties delsą) ir
šakų nuspėjimas (siekiant išlygiagretinti instrukcijų vykdymą).
Jei duotas algoritmas netinkamai išnaudoja šias mašinos galimybes, praktinis efektyvumas gali stipriai nukentėti.
Todėl bene geriausias būdas nustatyti tikėtiną praktinį algoritmo efektyvumą yra atlikti eksperimentus ir stebėti mašinos veikimą.
Žinoma, tokiu būdu gauti rezultatai priklauso nuo duotos mašinos techinių parametrų ir įvairių kitų veiksnių, tačiau didžioji dalis
šiuolaikinių kompiuterių pasitelkia tas pačias strategijas, tad pvz. lyginant kelių algoritmų veikimą
santykiniai rezultatų skirtumai neturėtų reikšmingai skirtis net ir atliekant matavimus skirtinguose kompiuteriuose.  

Reikia pastebėti, jog šiuolaikiniai kompiuteriai, nors ir sudėtingi, dažnai suteikia galimybes stebėti rodiklius, kurie labiausiai įtakoja veikimo laiką.
Tam dažniausiai yra pasitelkiami atskiri registrai, kuriuose saugomas pvz. neatspėtų šakų skaičius.
Šiuos rodiklius įprastai yra lengviau analizuoti pasitelkiant tam skirtus įrankius.
Šiame darbe buvo pasirinkta praktinei analizei naudoti \verb|perf| profiliuotoją, kadangi jis yra plačiai naudojamas, nemokamas ir jį naudoti nesudėtinga.
Kadangi \verb|perf| yra prieinamas tik Linux OS vartotojamas, buvo pasinaudota WSL funkcionalumu, kas leido jį naudoti kompiuteryje su Windows 11 OS.
Pastebėsime, jog naudojant WSL prieinama Linux OS veikia virtualioje mašinoje, tad tai gali paveikti gautus rezultatus. 

Eksperimentai buvo atliekami naudojant kompiuterį su 2.70 GHz Intel(R) Core(TM) i7-10850H procesoriumi ir 32 GB operatyviosios atminties.
Kadangi praktinis efektyvumas stipriai priklauso nuo konkrečios implementacijos, prieduose yra pateikiama eksperimentams naudota Šelo algoritmo implementacija C++ kalba.
Tiek naudojant \verb|perf|, tiek matuojant veikimo laiką ir atliekamas operacijas eksperimentai buvo vykdomi 5000000 kartų rikiuojant
atsitiktinai išmaišytus sveikus 32 bitų skaičius priklausančius intervalui $[0, size)$.
Siekiant išvengti neatitikimų, abi eksperimentų rūšys buvo vykdomos WSL aplinkoje su g++ 9.3 kompiliatoriumi naudojant \verb|-O2| optimizacijos lygmenį.
Kadangi \verb|perf| stebi visą programos veikimo laikotarpį, atliekant matavimus pirmiausia buvo išmatuojama kiek operacijų, ciklų ir pan. reikia vien duomenų generavimui,
vėliau juos atimant iš rodiklių, gautų atliekant rikiavimą.

Vykdant eksperimentus buvo nuspręsta tirti Šelo algoritmo veikimą rikiuojant 64 elementus.
Tai pakankamai svarbus scenarijus, kadangi jis tokiu principu dažnai pasitelkiamas hibridiniuose rikiavimo algoritmuose \cite{golangsort,bzip2sort}.
Tai taip pat palengvina analizę, kadangi ją atlikti su nedideliais duomenų dydžiais yra paprasčiau.

Pirmiausia buvo nutarta pamatuoti kelių skirtingų Šelo algoritmo variantų veikimo laiką ir atliekamas operacijas, siekiant nustatyti kaip tarpų sekos įtakoja šiuos kriterijus.
Tuo tikslu buvo pasirinkti du Šelo algoritmo variantai, kur pirmasis naudoja tarpų seką $\{1\}$ kas prilygsta rikiavimui įterpimu, o antrasis naudoja sutrumpintą Ciura tarpų seką $\{57,23,10,4,1\}$.
Pagal \ref{experiment_results_64} lentelėje matomus rezultatus matome, jog Šelo algoritmas atliko žymiai mažiau operacijų su Ciura tarpų seka, tačiau taip pat veikė reikšmingai lėčiau.

\begin{table}[H]
  \caption{Eksperimentų rezultatai matuojant veikimo laiką ir operacijas, kai $N = 64$}
  \label{experiment_results_64}
  \centering
  \begin{tabular}{@{}llll@{}}
  Tarpų seka            & palyginimai       & priskyrimai      & laikas (ciklais) \\ \midrule
  $\{1\}$               & 1067              & 1126             & 2544                  \\
  Ciura                 & 403               & 439              & 3873                  \\ \bottomrule
  \end{tabular}
\end{table}

Norint geriau suprasti gautus rezultatus, galima pasinaudoti \verb|perf| teikiamu funkcionalumu.
Naudojant \verb|perf| gauti rezultatai pateikiami \ref{perf_results_64} lentelėje.
Pastebėsime, jog kai kurie šiuo atveju neesminiai kriterijai nėra pateikiami, kadangi juos geriau atspindi kombinuoti kriterijai
(pvz. neverta pateikti viso atliktų šakų ir neatspėtų šakų, kai galime pateikti neatspėtų šakų santykį).
Pastebėsime, jog instrukcijos įvykdomos per ciklą iš dalies priklauso nuo procesoriaus gebėjimo atspėti šaką, kadangi jos neatspėjus tenka atstatyti prieš spėjimą buvusią būseną,
kas įprastai užtrunka nuo 10 iki 30 ciklų (priklauso nuo procesoriaus).
Analizuojant gautus rezultatus galima pastebėti, kad variantas su tarpų seka $\{1\}$ turi apytiksliai 6 kartus mažesnį neatspėtų šakų santykį bei įvykdo apytiksliai 3 kartus daugiau instrukcijų per ciklą.
Todėl, nors jis ir nėra efektyvus teorine prasme (atlieka daug palyginimų ir priskyrimų), praktikoje jis veikia reikšmingai greičiau, kadangi geriau išnaudoja procesoriaus galimybes.
Tiesa, rikiuojant sudėtingus duomenų tipus variantas su Ciura tarpų seka turėtų gauti palankesnius veikimo laiko rezultatus, kadangi atlieka mažiau operacijų.

\begin{table}[H]
  \caption{Rezultatai gauti naudojant perf, kai $N = 64$}
  \label{perf_results_64}
  \centering
  \begin{tabular}{@{}lll@{}}
  Tarpų seka            & instrukcijos/ciklai     & neatspėtos šakos \\ \midrule
  $\{1\}$               & 2.35                    & 3.44\%           \\
  $\{57,23,10,4,1\}$    & 0.71                    & 21.30\%          \\ \bottomrule
  \end{tabular}
\end{table}


Pirmiausia reikėtų išnagrinėti, nuo ko priklauso šakų atspėjamumas naudojant šias tarpų sekas.
Pastebėsime, jog rikiavimas įterpimu yra vienas palankiausių $O(n^2)$ algoritmų šakų nuspėjimui
ir rikiuojant neatspėjama $O(n)$ šakų \cite{biggar2005sorting}.
Tai lemia kelios priežastys: išorinio ciklo sąlyga yra lengvai nuspėjama, kadangi ji bus patenkinta tik perėjus visus elementus;
vidiniame cikle pirmiausia tikrinama, ar nepasiekta rikiuojamų duomenų pradžia (tai teisinga tik blogiausiu atveju),
o kita šaka priklauso nuo elementų palyginimo rezultato (sunkiausiai nuspėjama, kadangi priklauso nuo duomenų).
Reikia paminėti, jog rikiavimo įterpimu vidinis ciklas įprastai yra vykdomas keletą iteracijų (norint perstumti elementą per $n$ pozicijų, reikia atlikti tiek pat iteracijų)
ir todėl elementų palyginimo šaka yra santykinai lengvai nuspėjama.
Nors Šelo algoritmo šakų nuspėjamumas priklauso nuo naudojamos tarpų sekos, jis įprastai būna reikšmingai prastesnis nei rikiavimo įterpimu \cite{biggar2005sorting}.
Biggar et al. pastebėjo, jog su Gonnet tarpų seka Šelo algoritme per vieną iteraciją kiekvienas elementas yra pastumiamas apytiksliai per $0.9744 * h$ \cite{biggar2008experimental}.
Tai reiškia, kad vidinis ciklas, kuriame vykdomas rikiavimas įterpimu su tam tikru tarpu, retai kada atlieka daugiau nei vieną iteraciją, kas lemia, jog
vidiniame cikle vykdomo elementų palyginimo šaką yra sudėtinga nuspėti.

Kadangi prieš tai nagrinėtos tarpų sekos pastebimai skiriasi, buvo pasirinkta ištirti tarpų sekas, kurios yra gana paprastos ir tokio paties ilgio: $\{16, 1\}$, $\{32, 1\}$, $\{48, 1\}$.
Atliekant eksperimentus gauti rezultatai pateikiami \ref{perf_results2_64} lentelėje.
Remiantis gautais rezultatais, geriausią šakų nuspėjamumą turi tarpų seka $\{48, 1\}$.
Taip pat galime pastebėti, kaip mažėjant neatspėtų šakų skaičiui auga instrukcijų per ciklą skaičius bei didėja atliekamų operacijų skaičius.
Ir nors su tarpų seka $\{48, 1\}$ šakos nuspėjamos tiksliau bei atliekama daugiau instrukcijų per ciklą, su tarpų seka $\{32, 1\}$ veikimo laikas yra geresnis.
Tad vien šakų nuspėjimo tikslumas ir instrukcijų įvykdomų per ciklą kiekis pilnai nenusako veikimo spartos. 

\begin{table}[H]
  \caption{Eksperimentų rezultatai, kai $N = 64$}
  \label{perf_results2_64}
  \centering
  \begin{tabular}{@{}lllllll@{}}
  Tarpų seka             & instrukcijos/ciklai     & neatspėtos šakos  & palyginimai       & priskyrimai      & laikas (ciklais) \\ \midrule
  $\{16, 1\}$            & 1.29                    & 9.94\%            & 578               & 656              & 2822                  \\
  $\{32, 1\}$            & 1.74                    & 6.19\%            & 753               & 823              & 2579                  \\
  $\{48, 1\}$            & 1.93                    & 5.20\%            & 825               & 888              & 2618                  \\ \bottomrule
  \end{tabular}
\end{table}

Dabar panagrinėsime, kodėl buvo gauti būtent tokie rezultatai.
Tarpų seka $\{48, 1\}$ pirmame perėjime atlieka mažiau instrukcijų nei kitos tarpų sekos, kadangi jis vykdomas pradedant nuo indekso $48$,
tad atliekama viso 16 iteracijų, o kiekvienoje iteracijoje rikiuojamo posekio ilgis visada bus 2 (jei esame ties paskutiniu elementu, rikiuojamo posekio indeksai bus $\{63, 15\}$).
Tarpų seka $\{32, 1\}$ pirmame perėjime atliks 32 iteracijas ir kiekvieno rikiuojamo posekio ilgis taip pat bus 2.
Tarpų seka $\{16, 1\}$ pirmame perėjime atliks 48 iteracijas, tačiau rikiuojamo posekio ilgis didės kas 16 iteracijų (pradėjus rikiavimą
rikiuojamo posekio indeksai bus $\{16, 0\}$, o paskutinėje iteracijoje rikiuojamo posekio indeksai bus $\{63, 47, 31, 15\}$).
Remiantis tuo, įmanoma apskaičiuoti maksimaliai pirmame perėjime atliekamų palyginimų skaičių kiekvienai tarpų sekai:
$\{48, 1\}$ - $16 * 1 = 16$, $\{32, 1\}$ - $32 * 1 = 32$, $\{16, 1\}$ - $16 * 1 + 16 * 2 + 16 * 3 = 96$.
Tad tarpų seka $\{16, 1\}$ pirmame perėjime gali atlikti 6 kartus daugiau palyginimų, nei tarpų seka $\{48, 1\}$.

Tiesa, sunku pasakyti, kaip priklauso elementų palyginimo šakos nuspėjamumas priklausomai nuo tarpo dydžio.
Atlikus preliminarius matavimus rikiuojant vien su tarpais 16, 32 ir 48 nebuvo pastebėta reikšmingų skirtumų (visais atvejais neatspėtų šakų buvo apie 17\%).
Tad labiausiai tikėtina, jog tarpų sekų $\{48, 1\}$ ir $\{32, 1\}$ šakų nuspėjamumo rezultatai yra geresni, nes jos pirmame perėjime
atlieka mažiau instrukcijų, kas lemia, jog daugiau rikiavimo (tuo pačiu ir šakų) atliekama su tarpu 1, kur nuspėjamumas yra geresnis.

Vertinga pastebėti, jog atliekant perėjimą su tarpu $h$, kur $h > \lfloor\frac{N}{2}\rfloor$, vidiniame cikle galima netikrinti,
ar vidinio ciklo indeksas nėra mažesnis už tarpą, kadangi maksimalus iteracijų skaičius vidiniame cikle visada bus 1.
Šią sąlygą galima atlaisvinti iki $h \geq \lfloor\frac{N}{2}\rfloor$, jei nesirūpinama dėl pilno išrikiavimo paskutinėje iteracijoje.
Įterpimo perėjimo pakeitimas burbuliuko perėjimu tokiais atvejais gali būti prasmingas,
kadangi jis neturi vidinio ciklo, tad jo taikymas leistų atsisakyti vienos šakos ir kelių instrukcijų per iteraciją.  

Vertinant gautus rezultatus, taip pat pastebima, jog variantai su tarpų sekomis $\{48, 1\}$, $\{32, 1\}$, $\{16, 1\}$ lenkia variantą
su Ciura tarpų seka vertinant veikimo laiką ir beveik prilygsta variantui su tarpų seka $\{1\}$.
Žinoma, tam pasiekti jie atlieka daugiau operacijų, nei variantas su Ciura tarpų seka, tačiau taip pat atlieka reikšmingai mažiau operacijų nei variantas su tarpų seka $\{1\}$.
Tad šiuo atveju pasiekiamas tam tikras balansas tarp atliekamų operacijų ir veikimo laiko, ko ir yra siekiama šiame darbe.

\section{Šelo algoritmo variantų efektyvumo kriterijai}

Įprastai praktinis rikiavimo algoritmų efektyvumas yra vertinamas matuojant jų atliekamų palyginimų ar priskyrimų skaičių.
Tai yra pakankamai geri kriterijai norint praktiškai įvertinti duoto algoritmo efektyvumą su tam tikrais duomenų dydžiais,
kadangi teorinis laiko sudėtingumas nurodo tik algoritmo sudėtingumo funkcijos augimo greitį ir
neatsižvelgia į konstantas, kurios praktikoje taip pat įtakoja veikimo greitį \cite{biggar2005sorting}.

Pastebėsime, jog tiksliam efektyvumo įvertinimui tinkama matuoti tiek atliekamus palyginimus, tiek atliekamus priskyrimus.
To priežastis yra gana paprasta - rikiuojant duomenis, kurių palyginimas yra sudėtingas (pvz. simbolių eilutes),
algoritmo veikimo laiką stipriau įtakoja jo atliekamų palyginimų skaičiaus.
Analogiškas efektas pastebimas ir rikiuojant duomenis, kurių priskyrimas yra sudėtingas.
Vertinant Šelo algoritmo variantų efektyvumą būtina matuoti tiek atliekamus palyginimus, tiek atliekamus priskyrimus, kadangi
atliekamų palyginimų ir priskyrimų skaičiaus santykis priklauso nuo implementacijos ir augant $N$ nebūtinai artėja prie 1 \cite{Radavičius_Baranauskas_2013}.

% parasyt apie comparison itaka branch predictionui ir performance

Vertinant Šelo algoritmo variantų efektyvumą taip pat būtina atsižvelgti ir į veikimo laiką.
Savaime suprantama, jog į šį kriterijų verta žvelgti pakankamai kritiškai, kadangi jis priklauso nuo konkrečios algoritmo implementacijos,
eksperimentams naudojamos mašinos techninių parametrų ir kompiliatoriaus taikomų optimizacijų lygio.
Tačiau tai bene vienintelis kriterijus, leidžiantis įvertinti realų algoritmo praktinį efektyvumą, kas yra ypač svarbu,
kadangi naudojant šiuolaikinį kompiuterį labai sunku iš anksto nustatyti, kaip greitai algoritmas veiks praktikoje.
Atsižvelgiant į aukščiau pateiktus argumentus, galima teigti, jog
algoritmo veikimo laiko įvertis yra svarbus kriterijus įvertinant praktinį Šelo algoritmo varianto efektyvumą.

Remiantis aukščiau pateiktais argumentais, šiame darbe Šelo algoritmo variantai vertinami pagal
atliekamų palyginimų skaičių, atliekamų priskyrimų skaičių ir veikimo laiką.
Kiekvienas iš šių kriterijų yra vienodai svarbus įvertinant duoto algoritmo efektyvumą, tad svoriai šiems kriterijams nėra taikomi.

\section{Genetiniai algoritmai}

Paprasčiausias genetinis algoritmas susideda iš chromosomų populiacijos bei atrankos, mutacijos ir rekombinacijos operatorių \cite{simpson1999faster}.
Šiame skyriuje bus nagrinėjamos šių terminų reikšmės ir genetinių algoritmų veikimo principai.

\subsection{Chromosomų populiacija}

Chromosoma GA kontekste vadiname potencialų uždavinio sprendinį.
Projektuojant genetinį algoritmą tam tikro uždavinio sprendimui, svarbu tinkamai pasirinkti,
kaip kompiuteriu modeliuoti galimus sprendinius.
Įprastai siekiama sprendinio genus išreikšti kuo primityviau, siekiant
palengvinti mutacijos ir rekombinacijos operatorių taikymą.
Dažniausiai tai pasiekiama chromosomas išreiškiant bitų ar kitų primityvių duomenų tipų masyvais \cite{whitley1994genetic}.
Tada mutacija gali būti įgyvendinama tiesiog modifikuojant atsitiktinai pasirinktą masyvo elementą,
o rekombinacijai pakanka remiantis tam tikra strategija perkopijuoti tėvinių chromosomų elementus į vaikinę chromosomą.

Sprendinio kokybę įvardijame kaip jo tinkamumą, kuris apibrėžiamas tinkamumo funkcijos reikšme, pateikus sprendinį arba tarpinį sprendinio įvertį kaip parametrą.
Sprendžiant minimizavimo uždavinį, tinkamumo funkcija taip pat vadinama kainos funkcija.
Tinkamumo funkcija yra viena svarbiausių genetinio algoritmo dalių,
kadangi kai ji netinkamai parinkta, algoritmas nekonverguos į tinkamą sprendinį arba užtruks labai ilgai.

Chromosomų rinkinys, literatūroje dažnai vadinamas populiacija, atspindi uždavinio sprendinių aibę, kuri kinta kiekvieną genetinio algoritmo iteraciją.
Populiaciją dažnu atveju sudaro šimtai ar net tūkstančiai individų.
Populiacijos dydis dažnai priklauso nuo sprendžiamo uždavinio,
tačiau literatūroje nėra konsensuso, kokį populiacijos dydį rinktis bendru atveju.


\subsection{Genetiniai operatoriai}

Esminė GA dalis yra populiacijos genetinės įvairovės užtikrinimas, geriausių individų atranka ir kryžminimasis.
Siekiant užtikrinti šių procesų išpildymą, genetinis algoritmas vykdymo metu
iteratyviai atnaujina esamą populiaciją ir kuria naujas kartas
taikydamas biologijos žiniomis paremtus atrankos, rekombinacijos ir mutacijos operatorius.

Atrankos operatorius grąžina tinkamiausius populiacijos individus, kuriems yra leidžiama susilaukti palikuonių taikant rekombinacijos operatorių.
Dažniausiai atranka vykdoma atsižvelgiant į populiacijos individų tinkamumą, atrenkant ir pateikiant rekombinacijai tuos, kurių tinkamumas yra geriausias.
Verta pastebėti, jog įprastai rekombinacijai yra pasirenkama tam tikra fiksuota einamosios populiacijos dalis
ir daugelyje GA implementacijų šis dydis yra nurodomas kaip veikimo parametras.

Rekombinacijos operatorius įprastai veikia iš dviejų tėvinių chromosomų sukurdamas naują vaikinę chromosomą, kas dažniausiai pasiekiama
tam tikru būdu perkopijuojant tėvų genų atkarpas į vaikinę chromosomą.
Rekombinacijos strategijų yra įvairių, tačiau tinkamiausią strategiją galima pasirinkti tik atsižvelgiant į sprendžiamą uždavinį.

Mutacijos operatorius veikia modifikuojant pasirinktos chromosomos vieną ar kelis genus,
kas dažniausiai įgyvendinama nežymiai pakeičiant pasirinktų genų reikšmes ar sukeičiant jas vietomis.
Įprastai mutacija kiekvienai chromosomai taikoma su tam tikra tikimybe, kuri nurodoma kaip vienas iš GA veikimo parametrų.
Tinkamas chromosomos mutacijos tikimybės parinkimas yra vienas iš svarbiausių sprendimų projektuojant GA,
kadangi nuo mutacijos tikimybės dažnu atveju priklauso gaunamų sprendinių kokybė.
Jei mutacijos tikimybė yra per didelė, GA išsigimsta į primityvią atsitiktinę paiešką \cite{hassanat2019choosing} ir rizikuojama prarasti geriausius sprendinius.
Jei mutacijos tikimybė per maža, tai gali vesti prie genetinio dreifo \cite{masel2011genetic},
kas reiškia, jog populiacijos genetinė įvairovė palaipsniui mažės.

\section{Genetinis algoritmas Šelo algoritmo variantų generavimui}

% FIXME: tai chromosoma ar individas???

Pirmiausia reikėtų aptarti kaip turėtų būti modeliuojamas sprendinys, atspindintis tam tikrą Šelo algoritmo variantą.
Laikysime jog Šelo algoritmo variantą sudaro sąrašas porų $(p, h)$, kur $p$ yra skaičius, atitinkantis vieną iš anksčiau darbe aptartų perėjimų tipų,
o $h$ - tarpas, su kuriuo rikiuojama tame perėjime.
Toliau darbe tokiu būdu modeliuojamą Šelo algoritmo variantą vadinsime chromosoma arba individu, o porą $(p, h)$ - genu.
Tiesa, toks modelis neturi jokio funkcionalumo (juo duomenų rikiuoti negalime), tačiau tai nėra sunku išspręsti: pakanka kiekvienam perėjimo tipui
paruošti atitinkamą funkciją, kuri kaip parametrus priima rikiuojamus duomenis ir tarpą su kuriuo rikiuojama.
Tada modeliuojamą Šelo algoritmo variantą galima nesunkiai vykdyti iteruojant jo genų sąrašą ir kiekvienai porai $(p, h)$ iškviečiant funkciją atitinkančią jos tipą ir nurodant tarpą su kuriuo rikiuoti.

Taip pat labai svarbu apibrėžti kaip bus inicializuojami pradiniai sprendiniai, kurie bus naudojami genetinio algoritmo vykdymui.
Parinkti atsitiktinį perėjimo tipą yra nesudėtinga, kadangi pakanka sugeneruoti atsitiktinį skaičių, atitinkantį vieną iš apibrėžtų tipų.
Tuo tarpu greitai sugeneruoti pakankamai efektyvias tarpų sekas yra gana sudėtinga.
Tuo tikslu buvo pasirinkta individų inializacijai naudoti geometrines tarpų sekas, kadangi jas gana nesudėtinga generuoti
ir jos bendru atveju yra pakankamai efektyvios (didelė dalis efektyvių eksperimentiškai gautų tarpų sekų yra geometrinės).
Geometrinių tarpų sekų generavimo eiga yra pateikiama \ref{alg:geometric_gaps} algoritme.
Siekiant padidinti individų genetinę įvairovę, taip pat buvo pasirinkta dalį individų inicializuoti
tarpų sekomis, kurios generuojamos metodu panašiu į geometrinių tarpų sekų generavimą, koeficientą $q$ parenkant atsitiktinai kiekvienam tarpui.
Generuojant geometrines tarpų sekas buvo nuspręsta koeficientą $q$ parinkti atsitiktinai, užtikrinant, jog $1.5 \leq q \leq 7$.
Generuojant atsitiktines tarpų sekas taip pat buvo taikomas panašus principas, tačiau šiuo atveju naudotas toks $q$, kad $1.5 \leq q \leq 12.5$.

\begin{algorithm}[H]
  \caption{Geometrinių tarpų sekų generavimas}\label{alg:geometric_gaps}
  \begin{algorithmic}[1]
    \Procedure{geometric\_gaps}{$n, q$}
      \State let $gaps$ be an empty set
      \State $current \gets 1$
      
      \While{$current < n$}
        \State insert $\lceil current \rceil$ into $gaps$
        \State $current \gets current * q$ 
      \EndWhile

      \State \textbf{return} $gaps$
    \EndProcedure
  \end{algorithmic}
\end{algorithm}

Genetinio algoritmo įgyvendinimui buvo pasirinkta naudoti C++ programavimo kalbą ir openGA biblioteką \cite{mohammadi2017openga}.
C++ buvo pasirinkta dėl veikimo spartos ir patirties sukauptos ruošiant kursinį darbą ir kursinį projektą.
OpenGA biblioteka buvo pasirinkta dėl modernumo ir lygiagretaus vykdymo palaikymo.

Nors kriterijai Šelo algoritmo varianto efektyvumui įvertinti buvo apibrėžti praeitame skyriuje,
reikalinga plačiau aptarti kaip bus nustatoma duoto individo kaina.
Pirmiausia, siekiama, jog gautas algoritmas būtų deterministinis ir visada išrikiuotų duomenis, kadangi tikimybinių rikiavimo algoritmų panaudojamumas yra ribotas.
Todėl būtina po rikiavimo suskaičiuoti rikiuojamų duomenų inversijas ir šį kriterijų minimizuoti.
Taip pat reikia, jog pats inversijų skaičiavimas neužtruktų per ilgai, kadangi tai apsunkintų genetinio algoritmo vykdymą.
Šiuo tikslu buvo nuspręsta inversijų skaičiavimui pasitelkti modifikuotą rikiavimo sąlaja algoritmą, kurio sudėtingumas blogiausiu atveju yra $O(n\,log\,n)$.
Remiantis darbe iškelta hipoteze taip pat siekiama, jog sugeneruoti algoritmai veiktų greitai, todėl
vienas iš esminių kriterijų yra veikimo laikas.
Veikimo laiko matavimams buvo nuspręsta naudoti rikiavimo metu procesoriaus atliekamų ciklų skaičių pasitelkiant \verb|RDTSC| instrukciją.
Taip pat labai svarbu, jog algoritmo veikimo laikas stipriai nepriklausytų nuo rikiuojamų duomenų specifikos, tad 
būtina užtikrinti, jog atliekamų palyginimo ir priskyrimo operacijų skaičius būtų pakankamai mažas.
Operacijų skaičiavimui buvo pasitelkta projektiniame darbe naudota Element klasė, kuri naudojant palyginimo ir priskyrimo operatorių
perkrovimą seka šių operacijų skaičių rikiavimo metu.

Kaip buvo minėta įvade, Šelo algoritmo variantų generavimui buvo pasirinkta naudoti daugiakriterinį genetinį algoritmą.
Kadangi daugiakriteriniame GA svoriai netaikomi, buvo nuspręsta kai kuriems kriterijams taikyti prioritetus.
Tai reiškia, jog vienam iš kriterijų neatitinkant nustatyto apribojimo, kai kurie kiti kriterijai gali būti ignoruojami
tam, kad prioritetinis kriterijus atitiktų apribojimus.
Remiantis aukščiau aptartais tikslais, buvo nuspręsta taikyti prioritetus duomenų inversijoms bei veikimo laikui.
Laikant jog $i$ yra inversijų skaičius, $t$ - veikimo laikas (ciklais),
$c$ - palyginimų skaičius, $a$ - priskyrimų skaičius, o $T$ - tam tikra konstanta,
individo kainos funkcija yra apibrėžiama tokia forma:

\[
  cost(i, t, c, a)=
  \begin{cases}
    (i, \infty, \infty, \infty),& \text{if } i > 0\\
    (i, t, \infty, \infty),& \text{if } t > T\\
    (i, t, c, a), & \text{otherwise}
  \end{cases}
\]

% TODO: parasyt kiek kartu rikiavo, kokie duomenys rikiuoti
% TODO: parasyt apie individu atranka 


Individų mutacija buvo įgyvendinta pasirenkant atsitiktinį individo geną ir atsitiktinai pakeičiant jo perėjimo tipą kuriuo nors kitu.
Sprendinių rekombinacija buvo vykdoma tolygia strategija, kur dviejų tėvų genai turi vienodą tikimybę
būti perduoti vaikiniam individui.
Siekiant išvengti netinkamų sprendinių, rekombinacijos operatoriumi gauto naujo individo genai buvo išrikiuojami pagal tarpą naudojamą rikiavimui.

Atlikus pradinius eksperimentus ir preliminariai įvertinus gautų sprendinių tinkamumą buvo pasirinkta GA taikyti tokius parametrus:
populiacija - $500$, mutacijos tikimybė - $0.1$, rekombinuojama populiacijos dalis - $0.4$.
GA buvo nurodyta sustoti įvykdžius 100 iteracijų.

% FIXME: populiacija neteisinga su didesniu N, reiktu parasyt kiekvienam atskirai

\section{Šelo algoritmo variantų generavimas}

Šį skyrių sudaro trys poskyriai.
Pirmame poskyryje generuojami Šelo algoritmo variantai, kai $N = 128$.
Antrame poskyryje generuojami Šelo algoritmo variantai, kai $N = 1024$.
Trečiame poskyryje generuojami Šelo algoritmo variantai, kai $N = 8192$.

\subsection{Šelo algoritmo variantų generavimas, kai $N = 128$}

Šiame poskyryje siekiama sugeneruoti Šelo algoritmo variantus,
kurie leistų rikiuoti nedidelius duomenų dydžius greičiau nei žinomi variantai.
Genetinio algoritmo esminiai veikimo principai buvo apibrėžti praeitame skyriuje, tačiau
konstantos $T$, apibrėžiančios apribojimus veikimo laikui, reikšmė nebuvo apibrėžta.
Iš esmės $T$ reikšmė priklauso nuo duomenų dydžio - jei rikiuojama daugiau elementų, reikėtų pasirinkti didesnę $T$ reikšmę.
Natūralu būtų siekti apibrėžti funkciją $f$, kuri atitinkamam duomenų dydžiui grąžintų reikiamą $T$.
Tačiau tam reikėtų funkcijos, nusakančios apytikslį įvairių Šelo algoritmo variantų vidutinį veikimo laiką.
Kaip jau buvo minėta anksčiau, Šelo algoritmo vidutinio veikimo laiko analizė yra labai sudėtinga ir iš esmės priklauso nuo naudojamos tarpų sekos.
Todėl buvo pasirinkta generuojant Šelo algoritmo variantus tam tikram duomenų dydžiui pamatuoti vidutinį įvairių žinomų variantų veikimo laiką,
rasti apytikslį veikimo laikų vidurkį ir laikyti, jog šis skaičius yra $T$. % FIXME: pievos cia
Šiuo atveju pasirinkta naudoti $T = 9000$.

Suprojektuotas genetinis algoritmas buvo įvykdytas 50 kartų.
Viso buvo sugeneruota 890 skirtingų variantų.
Tada atsižvelgiant į veikimo laiką ir atliekamas operacijas buvo atrinkti 3 tinkamiausi variantai. % pridet daugiau apie procesa 

\subsection{Šelo algoritmo variantų generavimas, kai $N = 1024$}

Šiame poskyryje siekiama sugeneruoti Šelo algoritmo variantus,
kurie leistų rikiuoti vidutinius duomenų dydžius greičiau nei žinomi variantai.

\subsection{Šelo algoritmo variantų generavimas, kai $N = 8192$}

Šiame poskyryje siekiama sugeneruoti Šelo algoritmo variantus,
kurie leistų rikiuoti didelius duomenų dydžius greičiau nei žinomi variantai.

\section{Šelo algoritmo variantų efektyvumo įvertinimas}

\subsection{Duomenų rinkiniai}

Norint tinkamai įvertinti įvairių Šelo algoritmo variantų efektyvumą, yra būtina atlikti eksperimentus naudojant
įvairius duomenų rinkinius.
Idealiu atveju, tyrime taip pat naudojami skirtingi duomenų tipai (skaičiai, simbolių eilutės, etc.), kas leidžia įvertinti 
atliekamų palyginimų ir priskyrimų įtaką rikiavimo laikui.
Šiame darbe buvo pasirinkta naudoti sveikaskaitinius duomenis, generuojamus juos išdėstant 6 skirtingais būdais.
Šie duomenų išsidėstymo būdai yra apibrėžiami žemiau.

Dažniausiai literatūroje tiriant rikiavimo algoritmų efektyvumą yra sutinkami atsitiktiniai išsidėstę duomenys.
Šiame darbe buvo pasirinkta naudoti kelis šio duomenų išsidėstymo variantus.
Variantas \verb|shuffled_int| pirmiausia sugeneruoja sąrašą pavidalo $\{0, \dots, size-1\}$,
tada naudojant \verb|std::shuffle| funkciją šis sąrašas yra išmaišomas.
Reikia paminėti, jog \verb|std::shuffle| garantuoja, kad ją įvykdžius elementų tvarka yra atsitiktinė ir kiekvienas
skirtingas įmanomas elementų derinys turi vienodą tikimybę pasirodyti galutiniame sąraše.

Variantas \verb|shuffled_mod_sqrt| pirmiausia sugeneruoja sąrašą, kur kiekviena reikšmė yra formos $a \pmod{\lfloor \sqrt{size} \rfloor}$ ir $a \in \{0, \dots, size-1\}$,
o tada naudojant \verb|std::shuffle| šis sąrašas yra išmaišomas.
Šis duomenų rinkinys leidžia įvertinti, kaip veikia rikiavimo algoritmai, kai yra pakankamai daug dublikatų.

Variantas \verb|descending| sugeneruoja sąrašą pavidalo $\{size-1, \dots, 0 \}$,
t.y. elementai yra išdėstomi mažėjimo tvarka.
Šiuo atveju laikome, jog algoritmai rikiuoja didėjimo tvarka, tad toks duomenų rinkinys leidžia
įvertinti, kaip veikia tiriami rikiavimo algoritmai, kai duomenys yra išdėstyti nepalankia (atvirkščia) tvarka.
Tuo pačiu reikia pridurti, jog rinkinys, kur elementai išdėstyti didėjimo tvarka, šio tyrimo kontekste neturėtų prasmės ir todėl nėra įtraukiamas,
kadangi visiems Šelo algoritmo variantams tai yra geriausias atvejis (nereikia vykdyti jokių sukeitimų).
Lygiai tuo pačiu principu buvo pasirinkta neįtraukti ir duomenų rinkinio, kur visi elementai yra lygūs.

Variantas \verb|partially_sorted| sugeneruoja sąrašą pavidalo $\{0, \dots, size-1\}$,
tada naudojant \verb|std::shuffle| jį išmaišo, o po to dalinai jį išrikiuoja pasitelkiant \verb|std::partial_sort| funkciją.
Šiuo atveju dalinis rikiavimas atliekamas tokiu būdu, kad pirma pusė elementų yra išrikiuoti, o antra pusė elementų yra išdėstyti atsitiktine tvarka.
Šis duomenų rinkinys leidžia įvertinti, kaip veikia rikiavimo algoritmai, kai į vieną yra sujungiami du sąrašai, kur pirmas sąrašas yra išrikiuotas, o antras ne.
Galima nesunkiai įsivaizduoti tokio duomenų išsidėstymo pasitaikymo atvejį praktikoje - tarkime, programa turi duomenis kurie yra išrikiuoti,
gauna daugiau duomenų, šiuos sąrašus sujungia ir vėl išrikiuoja, siekiant išlaikyti jų tvarką.

Variantas \verb|merge| sugeneruoja du sąrašus pavidalo $\{0, \dots, \lfloor size/2 \rfloor\}$ ir juos sujungia į vieną.
Šis duomenų rinkinys leidžia įvertinti, kaip veikia rikiavimo algoritmai, kai vieną sąrašą sudaro du išrikiuoti nuoseklūs posekiai.
Praktinis šio duomenų rinkinio naudojimo atvejis yra gana panašus į \verb|partially_sorted| duomenų rinkinio.
Reikia pastebėti, jog šis atvejis su praktikoje sutinkamais duomenimis yra gana dažnas, dėl to pvz.
Timsort algoritmas, kuris sugeba išnaudoti duomenyse pasitaikančius išrikiuotus posekius efektyvesniam rikiavimui, yra taip plačiai naudojamas \cite{auger2015merge}.

Variantas \verb|push_min| sugeneruoja sąrašą pavidalo $\{1, \dots, size-1, 0\}$, t.y. visi elementai, išskyrus paskutinį, yra išrikiuoti.
Šis duomenų rinkinys leidžia įvertinti, kaip veikia rikiavimo algoritmai, kai į išrikiuoto sąrašo galą yra pridedamas dar vienas elementas ir siekiama vėl užtikrinti duomenų tvarką.
Šis atvejis yra gana nepalankus, kadangi neišrikiuotas yra tik vienas elementas, tačiau jį yra būtina perstumti į kitą sąrašo galą.
Galima nesunkiai įsivaizduoti tokio duomenų išsidėstymo pasitaikymo atvejį praktikoje, ypač jei siekiant išlaikyti duomenų tvarką dėl ribotos standartinės bibliotekos ar
žinių trūkumo pasirenkama naudoti ne prioritetinę eilę, o duomenis kaskart išrikiuoti.

\subsection{Tyrimo metodika}

Atliekant tyrimą buvo pasirinkta įvertinti sugeneruotų ir geriausiai žinomų Šelo algoritmo variantų efektyvumą.
Tuo tikslu buvo pasirinkta gautus variantus lyginti su optimizuotu Šelo algoritmu naudojant šias tarpų sekas:

\begin{itemize}
  \item Ciura: $1, 4, 10, 23, 57, 132, 301, 701$ \cite{ciura2001best}
  \item Tokuda: $1, 4, 9, 20, 46, 103, 233, 525, \ldots $ \cite{tokuda1992}
  \item Sedgewick: $1, 5, 19, 41, 109, 209, 505, 929, \ldots$ \cite{SEDGEWICK1986159}
\end{itemize}

Kadangi Ciura seka yra baigtinė, didesnių duomenų dydžių rikiavimui ji buvo pratęsta pasitelkiant rekursyvią formulę $h_{k}=\lfloor 2.25h_{k-1}\rfloor$.
Sedgewick ir Tokuda sekos yra begalinės, tad jos buvo sutrumpintos taip, jog gauta seka būtų ilgiausia įmanoma seka, kurios visi elementai mažesni už 8192 (maksimalų tirtą duomenų dydį).

Kadangi darbe buvo generuojami algoritmai, leidžiantys efektyviai rikiuoti tris skirtingus duomenų dydžius, tyrimą sudaro trys algoritmų rinkiniai.
Kiekvieną rinkinį sudaro literatūroje pateikti algoritmai bei darbo eigoje sugeneruoti algoritmai
(pvz. pirmą rinkinį sudaro A1, A2, A3 algoritmai bei Šelo algoritmas su Ciura, Tokuda ir Sedgewick tarpų sekomis).
Su kiekvienu iš šių rinkinių eksperimentai atliekami naudojant tris skirtingus duomenų dydžius: $\frac{N}{2^2}$, $\frac{N}{2}$, $N$.
Čia $N$ yra duomenų dydis, su kuriuo pasitelkiant GA buvo sugeneruota dalis to rinkinio algoritmų (pvz. pirmam rinkiniui naudojami duomenų dydžiai 32, 64, 128).

% FIXME: aprasyt detaliai viska iskart, o ne abstrakciai

Atliekant efektyvumo tyrimą buvo pasirinkta kiekvienai algoritmo ir duomenų rinkinio porai
atlikti matavimus tol, kol praeis 10 sekundžių.
Tokiu būdu atliekamų matavimų skaičius automatiškai prisitaiko prie duomenų dydžio
ir rezultatai gauti su mažesniais duomenų dydžiais yra tikslesni.
Siekiant padidinti rezultatų tikslumą, kiekviena algoritmo ir duomenų rinkinio pora
prieš atliekant matavimus buvo 2 sekundes apšildoma atliekant rikiavimą ir nefiksuojant rezultatų.
Tai leido apšildyti procesoriaus talpyklas ir sumažinti tikimybę,
jog procesoriaus veikimo dažnis ženkliai pasikeis atliekant matavimus.

Kiekvienai algoritmo ir atsitiktinio duomenų rinkinio porai taip pat buvo naudojama ta pati pradinė reikšmė,
kuri inicializuoja \verb|std::shuffle| naudojamą atsitiktinių skaičių generatorių.
Tad iš esmės kiekvienas algoritmas tam tikrame duomenų rinkinyje turėtų rikiuoti tokius pat pradinius duomenis.

Siekiant jog gauti rezultatai būtų statistiškai reikšmingi, buvo pasirinkta naudoti tarpkvartilinio diapazono (angl. interquartile range) metodą.
Šis metodas leidžia aptikti nuokrypius, kas leidžia nustatyti nenumatytų veiksnių įtaką gautiems rezultatams.
Tai ypač svarbu matuojant veikimo laiką, kadangi jį labiausiai paveikia išorinių veiksnių įtaka.
Taip pat tarpkvartilinis diapazonas nurodo rezultatų sklaidą aplink medianą,
kas leidžia nustatyti atliktų matavimų paklaidą.

\subsection{Tyrimo aplinka}

Eksperimentų vykdymui buvo naudojamas kompiuteris su 2.70 GHz Intel(R) Core(TM) i7-10850H procesoriumi,
32 GB operatyviosios atminties ir Windows 11 operacine sistema.
Efektyvumo tyrimas buvo įgyvendintas C++ kalba su MSVC 19.16.27043 kompiliatoriumi.

\subsection{Tyrimo rezultatai}

\subsubsection{Pirmas algoritmų rinkinys}

\begin{figure}[H]
  \centering
  \includegraphics[scale=1]{img/cycles_bench_results_128_128.jpg}
  \caption{Veikimo laikas su $N = 128$}
  \label{img:bench_cycles_128}
\end{figure}

\begin{figure}[H]
  \centering
  \includegraphics[scale=1]{img/cmp_bench_results_128_128.jpg}
  \caption{Atliekami palyginimai su $N = 128$}
  \label{img:bench_comparisons_128}
\end{figure}


\begin{figure}[H]
  \centering
  \includegraphics[scale=1]{img/asg_bench_results_128_128.jpg}
  \caption{Atliekami priskyrimai su $N = 128$}
  \label{img:bench_assignments_128}
\end{figure}


\subsubsection{Antras algoritmų rinkinys}


\begin{figure}[H]
  \centering
  \includegraphics[scale=1]{img/cycles_bench_results_1024_1024.jpg}
  \caption{Veikimo laikas su $N = 1024$}
  \label{img:bench_cycles_1024}
\end{figure}

\begin{figure}[H]
  \centering
  \includegraphics[scale=1]{img/cmp_bench_results_1024_1024.jpg}
  \caption{Atliekami palyginimai su $N = 1024$}
  \label{img:bench_comparisons_1024}
\end{figure}


\begin{figure}[H]
  \centering
  \includegraphics[scale=1]{img/asg_bench_results_1024_1024.jpg}
  \caption{Atliekami priskyrimai su $N = 1024$}
  \label{img:bench_assignments_1024}
\end{figure}


\subsubsection{Trečias algoritmų rinkinys}

\begin{figure}[H]
  \centering
  \includegraphics[scale=1]{img/cycles_bench_results_8192_8192.jpg}
  \caption{Veikimo laikas su $N = 8192$}
  \label{img:bench_cycles_8192}
\end{figure}

\begin{figure}[H]
  \centering
  \includegraphics[scale=1]{img/cmp_bench_results_8192_8192.jpg}
  \caption{Atliekami palyginimai su $N = 8192$}
  \label{img:bench_comparisons_8192}
\end{figure}


\begin{figure}[H]
  \centering
  \includegraphics[scale=1]{img/asg_bench_results_8192_8192.jpg}
  \caption{Atliekami priskyrimai su $N = 8192$}
  \label{img:bench_assignments_8192}
\end{figure}

\sectionnonum{Išvados}
% Išvadose ir pasiūlymuose, nekartojant atskirų dalių apibendrinimų,
% suformuluojamos svarbiausios darbo išvados, rekomendacijos bei pasiūlymai.

\sectionnonum{Conclusions}
% Šiame skyriuje pateikiamos išvados (reziume) anglų kalba.


\printbibliography[heading=bibintoc]

\appendix  % Priedai

\section{Eksperimentams naudota Šelo algoritmo implementacija}

\begin{lstlisting}[label={alg:test_shellsort},language=C++]
template <typename T>
inline void test_shellsort(T & data) {
    const int gaps[] = { 1 };
    const int size = data.size();

    for (int gap: gaps) {
        for (int i = gap; i < size; i++) {
            if (data[i - gap] > data[i]) {
                auto temp = data[i];
                int j = i;

                do {
                    data[j] = data[j - gap];
                    j -= gap;
                } while (j >= gap && data[j - gap] > temp);

                data[j] = temp;
            }
        }
    }
}
\end{lstlisting}

\section{GA sugeneruoti Šelo algoritmo variantai, kai $N = 128$}

\begin{lstlisting}[caption={Algoritmas A1},label={alg:A1},language=json]
  [
    {"gap":52,"passType":"bubble"}, 
    {"gap":6,"passType":"insertion"}, 
    {"gap":1,"passType":"insertion"}
  ]
\end{lstlisting}

\begin{lstlisting}[caption={Algoritmas A2},label={alg:A2},language=json]
  [
    {"gap":92,"passType":"shake"}, 
    {"gap":7,"passType":"insertion"}, 
    {"gap":1,"passType":"insertion"}
  ]
\end{lstlisting}

\begin{lstlisting}[caption={Algoritmas A3},label={alg:A3},language=json]
  [
    {"gap":76,"passType":"bubble"}, 
    {"gap":10,"passType":"insertion"}, 
    {"gap":1,"passType":"insertion"}
  ]
\end{lstlisting}

\section{GA sugeneruoti Šelo algoritmo variantai, kai $N = 1024$}

\begin{lstlisting}[caption={Algoritmas B1},label={alg:B1},language=json]
  [
    {"gap":162,"passType":"insertion"}, 
    {"gap":40,"passType":"insertion"}, 
    {"gap":17,"passType":"insertion"}, 
    {"gap":4,"passType":"insertion"}, 
    {"gap":1,"passType":"insertion"}
  ]
\end{lstlisting}

\begin{lstlisting}[caption={Algoritmas B2},label={alg:B2},language=json]
  [
    {"gap":155,"passType":"insertion"}, 
    {"gap":19,"passType":"insertion"}, 
    {"gap":5,"passType":"insertion"}, 
    {"gap":1,"passType":"insertion"}
  ]
\end{lstlisting}

\begin{lstlisting}[caption={Algoritmas B3},label={alg:B3},language=json]
  [
    {"gap":97,"passType":"insertion"}, 
    {"gap":26,"passType":"insertion"}, 
    {"gap":8,"passType":"insertion"}, 
    {"gap":1,"passType":"insertion"}
  ]
\end{lstlisting}


\section{GA sugeneruoti Šelo algoritmo variantai, kai $N = 8192$}

\begin{lstlisting}[caption={Algoritmas C1},label={alg:C1},language=json]
  [
    {"gap":1794,"passType":"insertion"}, 
    {"gap":615,"passType":"shake"}, 
    {"gap":264,"passType":"insertion"}, 
    {"gap":104,"passType":"insertion"}, 
    {"gap":25,"passType":"insertion"}, 
    {"gap":11,"passType":"insertion"}, 
    {"gap":4,"passType":"insertion"}, 
    {"gap":1,"passType":"insertion"}
  ]
\end{lstlisting}

\begin{lstlisting}[caption={Algoritmas C2},label={alg:C2},language=json]
  [
    {"gap":1794,"passType":"insertion"}, 
    {"gap":1152,"passType":"brick"}, 
    {"gap":356,"passType":"insertion"}, 
    {"gap":104,"passType":"insertion"}, 
    {"gap":25,"passType":"insertion"}, 
    {"gap":11,"passType":"insertion"}, 
    {"gap":4,"passType":"insertion"}, 
    {"gap":1,"passType":"insertion"}
  ]
\end{lstlisting}

\begin{lstlisting}[caption={Algoritmas C3},label={alg:C3},language=json]
  [
    {"gap":760,"passType":"insertion"}, 
    {"gap":187,"passType":"insertion"}, 
    {"gap":53,"passType":"insertion"}, 
    {"gap":19,"passType":"insertion"}, 
    {"gap":6,"passType":"insertion"}, 
    {"gap":1,"passType":"insertion"}
  ]
\end{lstlisting}

\end{document}
