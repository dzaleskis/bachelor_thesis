\documentclass{VUMIFInfBakalaurinis}
\usepackage{algorithmicx}
\usepackage{algorithm}
\usepackage{algpseudocode}
\usepackage{amsfonts}
\usepackage{amsmath}
\usepackage{bm}
\usepackage{caption}
\usepackage{color}
\usepackage{float}
\usepackage{graphicx}
% \usepackage{hyperref}  % Nuorodų aktyvavimas
\usepackage{listings}
\usepackage{subfig}
\usepackage{url}
\usepackage{wrapfig}
\usepackage{booktabs}
\usepackage[table,xcdraw]{xcolor}

\algnewcommand\algorithmicforeach{\textbf{foreach}}
\algdef{S}[FOR]{ForEach}[1]{\algorithmicforeach\ #1\ \algorithmicdo}

\definecolor{eclipseStrings}{RGB}{127,0,85}
\definecolor{eclipseKeywords}{RGB}{42,0,255}
\colorlet{numb}{magenta!60!black}

\lstset{
  basicstyle=\normalfont\ttfamily,
  commentstyle=\color{eclipseKeywords}, % style of comment
  stringstyle=\color{eclipseStrings}, % style of strings
  backgroundcolor=\color{white},
  showstringspaces=false,
  breaklines=true,
  frame=lines,
}

% Titulinio aprašas
\university{Vilniaus universitetas}
\faculty{Matematikos ir informatikos fakultetas}
\institute{Informatikos institutas}
\department{Informatikos katedra}
\papertype{Baigiamasis bakalauro darbas}
\title{Rikiavimo tobulinimas genetiniais algoritmais}
\titleineng{Improving Sorting with Genetic Algorithms}
\status{4 kurso 2 grupės studentas}
\author{Deividas Zaleskis}
\supervisor{Irmantas Radavičius}
\reviewer{Vardukas Pavardukas}
\date{Vilnius \\ \the\year}

\bibliography{bibliografija} 

\begin{document}
\maketitle

\tableofcontents

\sectionnonum{Sąvokų apibrėžimai}
% Sutartinių ženklų, simbolių, vienetų ir terminų sutrumpinimų sąrašas (jeigu
% ženklų, simbolių, vienetų ir terminų bendras skaičius didesnis nei 10 ir
% kiekvienas iš jų tekste kartojasi daugiau nei 3 kartus).

Šelo algoritmas
GA
OS
WSL

\sectionnonum{Įvadas}

Duomenų rikiavimas yra vienas aktyviausiai tiriamų uždavinių informatikos moksle.
Iš dalies tai lemia rikiavimo uždavinio prieinamumas ir analizės paprastumas.
Formaliai rikiavimo uždavinys formuluojamas taip:
duotai baigtinei palyginamų elementų sekai $S = (s_1, s_2, ..., s_n)$ pateikti tokį
kėlinį, kad duotosios sekos elementai būtų išdėstyti monotonine (didėjančia arba mažėjančia) tvarka.
Kadangi rikiavimo uždavinio sąlyga yra gana paprasta, tai suteikia didelę galimų implementacijų įvairovę.
Todėl nauji rikiavimo algoritmai ir įvairūs patobulinimai egzistuojantiems algoritmams yra kuriami ir dabar.

Rikiavimo uždavinys yra fundamentalus, kadangi rikiavimas padeda pagrindą efektyviam kitų uždavinių sprendimui.
Kaip to pavyzdį galima pateikti dvejetainės paieškos algoritmą, kurio prielaida,
jog duomenys yra išrikiuoti, leidžia sumažinti paieškos laiko sudėtingumą iki $O(log\,n)$.
Rikiavimas taip pat svarbus duomenų normalizavimui bei pateikimui žmonėms lengvai suprantamu formatu.
Kadangi duomenų rikiavimas yra fundamentalus uždavinys, net ir nežymūs patobulinimai žvelgiant bendrai
gali atnešti didelę naudą.

Rikiavimo uždaviniui spręsti egzistuoja labai įvairių algoritmų.
Plačiausiai žinomi yra klasikiniai rikiavimo algoritmai: rikiavimas sąlaja (angl. merge sort), rikiavimas įterpimu (angl. insertion sort) ir greitojo rikiavimo algoritmas (angl. quicksort).
Tiesa, šie algoritmai turi įvairių trukūmų:
rikiavimas sąlaja dažnai veikia lėčiau nei nestabilūs algoritmai ir naudoja $O(n)$ papildomos atminties, rikiavimas įterpimu yra efektyvus tik kai rikiuojamų duomenų dydis yra mažas, o
greitojo rikiavimo algoritmas blogiausiu atveju turi $O(n^2)$ laiko sudėtingumą.
Todėl šiuo metu praktikoje plačiausiai naudojami hibridiniai rikiavimo algoritmai, kurie apjungia kelis klasikinius algoritmus į vieną panaudodami jų geriausias savybes.
Pavyzdžiui, C++ programavimo kalbos standartinėje bibliotekoje naudojamas introspektyvaus rikiavimo (angl. introsort) algoritmas įprastai naudoja greitojo rikiavimo algoritmą,
pasiekus tam tikrą rekursijos gylį yra naudojamas rikiavimas krūva (angl. heapsort) siekiant išvengti $O(n^2)$ laiko sudėtingumo,
o kai rikiuojamų duomenų dydis yra pakankamai mažas, pasitelkiamas rikiavimas įterpimu, kadangi su mažais duomenų dydžiais jis yra efektyvesnis.
Apibendrinant, pasitelkiant įvairius klasikinius rikiavimo algoritmus ir jų unikalias savybes yra įmanoma rikiavimo uždavinį spręsti efektyviau.

Vienas iš teorine prasme įdomiausių klasikinių algoritmų yra Šelo rikiavimo algoritmas.
Šelo algoritmą galima laikyti rikiavimo įterpimu optimizacija, kadangi atliekant rikiavimą yra lyginami ne tik gretimi elementai,
kas leidžia kai kuriuos elementus perkelti į galutinę poziciją atliekant mažiau operacijų.
Pagrindinė algoritmo idėja - išskaidyti rikiuojamą seką $S$ į posekius $S_1, S_2, ..., S_n$, kur
$S_i = (s_i, s_{i+h}, s_{i+2h}, ...)$ ir atskirai išrikiuoti kiekvieną posekį $S_i$.
Įprastai tarpų rinkinys, kuriuo remiantis formuojami rikiuojami posekiai, vadinamas tarpų seka.
Šelo algoritmo efektyvumas priklauso nuo pasirinktos tarpų sekos, todėl bendra teorinė šio algoritmo analizė yra labai sudėtinga.
Taip pat reikia pastebėti, jog praktikoje efektyviausi yra eksperimentiškai gauti Šelo algoritmo variantai \cite{ciura2001best,tokuda1992}.

Vienas iš eksperimentinių metodų, kuriuos galima taikyti efektyvių Šelo algoritmo variantų radimui, yra genetinis algoritmas.
Genetinis algoritmas yra metodas paremtas žiniomis apie natūralios atrankos procesą, leidžiantis efektyviai spręsti paieškos ir optimizavimo uždavinius.
Pagrindinis genetinių algoritmų veikimo principas yra pradinės populiacijos generavimas ir iteratyvus jos atnaujinimas, siekiant, jog
bendra populiacijos kokybė didėtų kiekvieną iteraciją.
Populiacijos atnaujinimas yra vykdomas pasitelkiant biologijos įkvėptus atrankos, rekombinacijos ir mutacijos operatorius.

Literatūroje galima rasti darbų \cite{roos2002genetic,simpson1999faster}, kuriuose genetiniai algoritmai yra taikomi naujų Šelo algoritmo variantų radimui.
Simpson-Yachavaram darbe daugiausia dėmesio skiriama atliekamiems palyginimams, teigiama, jog gauti variantai atlieka mažiausiai palyginimo operacijų,
tačiau jie yra lyginami tik su Sedgewick ir Incerpi-Sedgewick variantais.
Šiuo metu yra laikoma, jog vidutiniškai atliekamų palyginimų atžvilgiu optimaliausias yra Ciura \cite{ciura2001best} variantas.
Roos et al. darbe daugiausia dėmesio skiriama veikimo laikui, teigiama, jog gautas variantas veikia greičiau nei kiti tirti variantai, tačiau
pateikiamuose rezultatuose jis lyginamas tik su Simpson-Yachavaram variantu, tiriami tik keli duomenų dydžiai.
Nepaisant aukščiau aprašytų darbų trūkumų, juose pateikiami rezultatai rodo, jog genetinių algoritmų taikymas Šelo algoritmo variantų konstravimui
gali būti prasmingas ir duoti reikšmingų rezultatų.

Atliekant kursinį projektą buvo atlikti pradiniai eksperimentai, siekiant genetinių algoritmų pagalba sugeneruoti efektyvius Šelo algoritmo variantus.
Viena iš problemų, su kuriomis buvo susidurta tame darbe, buvo pusiausvyros tarp atliekamų operacijų ir veikimo laiko išlaikymas, kadangi
algoritmai, kurie atlieka labai mažai operacijų, tačiau veikia lėtai, nėra ypač naudingi praktiniams taikymams, o  
algoritmai, kurie veikia greitai, tačiau atlieka labai daug operacijų, rikiuojant sudėtingus duomenų tipus gali reikšmingai sulėtėti.
Todėl prasmingiausia ieškoti naujų Šelo algoritmo variantų pasitelkiant tokį metodą, kuris išlaikytų pusiausvyrą tarp veikimo laiko ir atliekamų operacijų,
neteikdamas prioriteto nei vienam iš šių kriterijų.
Kursiniame projekte variantų generavimui buvo pasitelktas vienkriterinis genetinis algoritmas, veikimo laiko ir atliekamų operacijų pusiausvyros problemai spręsti
naudotas svorinės sumos metodas.
Retrospektyviai galima teigti, jog šis sprendimas nebuvo teisingas, kadangi skirtingų kriterijų pusiausvyros išlaikymą
pasitelkiant šį metodą buvo sudėtinga įgyvendinti, o dėl pasirinktų svorių didžiausią įtaką turėjo atliekami palyginimai.
Atsižvelgiant į kursinio projekto trūkumus, šiame darbe pasirinkta naudoti daugiakriterinį genetinį algoritmą, kuris
padėtų sugeneruoti efektyvius Šelo algoritmo variantus bei išlaikytų tinkamą pusiausvyrą tarp atliekamų operacijų ir veikimo laiko.

\pagebreak

Keliama tokia \textbf{hipotezė}:

\textit{Pasitelkiant genetinius algoritmus įmanoma sukonstruoti efektyvius Šelo algoritmo variantus,
kurių vidutinis veikimo laikas būtų mažesnis nei šiuo metu žinomų variantų.}

\medskip

Siekiant patikrinti iškeltą hipotezę, reikia atlikti šiuos uždavinius:
\begin{itemize}
    \item Išanalizuoti Šelo algoritmą ir jo variantus remiantis literatūra;
    \item Išanalizuoti Šelo algoritmo veikimą atliekant eksperimentus;
    \item Nustatyti kriterijus Šelo algoritmo variantų efektyvumui įvertinti;
    \item Realizuoti genetinį algoritmą Šelo algoritmo variantų generavimui;
    \item Pasitelkiant realizuotą genetinį algoritmą sugeneruoti Šelo algoritmo variantus;
    \item Eksperimentiškai palyginti sugeneruotų ir pateiktų literatūroje Šelo algoritmo variantų efektyvumą.
  \end{itemize}

\medskip

Šiame darbe atlikta:
\begin{itemize}
    \item Atlikta Šelo algoritmo ir jo variantų literatūros analizė;
    \item Atlikti eksperimentai, kurie leido nustatyti šakų spėjimo įtaką Šelo algoritmo veikimo laikui su nedideliais duomenų dydžiais;
    \item Realizuotas genetinis algoritmas, leidžiantis generuoti Šelo algoritmo variantus, kurie išlaiko pusiausvyrą tarp veikimo laiko ir atliekamų operacijų;
    \item Pasitelkiant realizuotą genetinį algoritmą sugeneruoti Šelo algoritmo variantai, leidžiantys efektyviai rikiuoti įvairius duomenų dydžius;
    \item Atlikti eksperimentai, kuriais patvirtinta, jog sugeneruoti Šelo algoritmo variantai su pasirinktais duomenų dydžiais veikia greičiau, nei žinomi variantai;
\end{itemize}

\medskip

Darbas remiasi tokiomis prielaidomis:
\begin{itemize}
    \item Atliekant Šelo algoritmo variantų generavimą ir tarpusavio palyginimą rikiuojamų duomenų palyginimo ir priskyrimo sudėtingumas laiko atžvilgiu yra $O(1)$;
    \item Atliekant Šelo algoritmo variantų tarpusavio palyginimą yra pakankama aprėpti geriausiai žinomus variantus
        (visų literatūroje pateiktų variantų tarpusavio palyginimas reikalautų atskiro tyrimo);
    \item Šelo algoritmo variantų tarpusavio palyginimui pasirinkti duomenų rinkiniai pakankamai tiksliai atspindi dažniausiai praktikoje sutinkamus duomenų rinkinius.
\end{itemize}


\section{Šelo algoritmas}

\subsection{Klasikinis Šelo algoritmas}

Šelo algoritmas yra vienas iš seniausių ir geriausiai žinomų rikiavimo algoritmų.
Šelo algoritmas yra paremtas palyginimu, adaptyvus, nestabilus ir nenaudojantis papildomos atminties.
Yra įrodyta, kad Šelo algoritmo laiko sudėtingumo blogiausiu atveju apatinė riba yra
$\Omega(\frac{n\,log^2\,n}{log\,log\,n^2})$ \cite{plaxton1992}, tad jis nėra asimptotiškai optimalus.
Šio algoritmo laiko sudėtingumo analizė vidutiniu atveju yra labai sudėtinga
ir lieka atvira problema \cite{ciura2001best,Radavičius_Baranauskas_2013}.
Nepaisant sudėtingos analizės, Šelo algoritmas yra nesunkiai įgyvendinamas ir gana lengvai suprantamas.
Tai įrodo ir pseudokodas, pateikiamas \ref{alg:shellsort} algoritme.

\begin{algorithm}[H]
  \caption{Šelo algoritmas}\label{alg:shellsort}
  \begin{algorithmic}[1]
  \ForEach {$h$ \textbf{in} $H$}
    \For {$i\gets h$ \textbf{to} $N-1$}
      \State $j\gets i$
      \State $temp\gets S[i]$
      \While {$j > h$ \textbf{and} $S[j - h] > S[j]$}
        \State $S[j]\gets S[j - h]$
        \State $j\gets j-h$
      \EndWhile
      \State $S[j]\gets temp$
    \EndFor
  \EndFor
  \end{algorithmic}
\end{algorithm}

\subsection{Optimizuotas Šelo algoritmas}

Reikia pastebėti, jog klasikinis Šelo algoritmas nėra optimizuotas ir tam tikrais atvejais atlieka nereikalingas operacijas.
Jei vykdant vidinį Šelo algoritmo ciklą esamas elementas $S[j]$ nėra mažesnis už elementą $S[j-h]$,
$while$ ciklas kuriame atliekama esminė rikiavimo logika nebus vykdomas, tad du priskyrimai bus atlikti veltui.
Optimizuota Šelo algoritmo versija \cite{Radavičius_Baranauskas_2013} patikrina ar esamas elementas yra mažesnis už elementą $S[j-h]$ ir tik tada vykdo vidinį ciklą.
Tai leidžia sumažinti atliekamų priskyrimų skaičių 40-80\% ir sumažinti veikimo laiką apytiksliai 20\%, lyginant su klasikine implementacija.
Toliau darbe naudojama ir analizuojama tik optimizuota Šelo algoritmo implementacija. 

\begin{algorithm}[H]
    \caption{Optimizuotas Šelo algoritmas}\label{alg:shellsort_optimized}
    \begin{algorithmic}[1]
      \ForEach {$h$ \textbf{in} $H$}
        \For {$i\gets h$ \textbf{to} $N-1$}
          \If {$S[i-h] > S[i]$}
            \State $j\gets i$
            \State $temp\gets S[i]$
            \Repeat
              \State $S[j]\gets S[j - h]$
              \State $j\gets j-h$
            \Until {$j \le h$ or $S[j - h] \le S[j]$}
            \State $S[j]\gets temp$
          \EndIf
        \EndFor
      \EndFor
    \end{algorithmic}
  \end{algorithm}

\subsection{Šelo algoritmo variantai}

Šelo algoritmas pasižymi variantų gausa.
Šelo algoritmą iš esmės galima laikyti tarpų sekos iteravimu, su kiekvienu iš tarpų atliekant tam tikro posekio rikiavimą.
Tad norint patobulinti Šelo algoritmą galima keisti tiek posekių formavimą (naudojant kitokią tarpų seką), tiek posekių rikiavimo logiką.
Šioje darbo dalyje nagrinėjami tie variantai, kurie nuo originalios versijos skiriasi taikoma posekių rikiavimo logika.

Siekiant supaprastinti skirtingų Šelo algoritmo variantų palyginimą, galima išskirti dvi sudėtines kiekvieno varianto dalis:
visiems variantams bendrą struktūrą ir konkrečiam variantui būdingą posekių rikiavimo logiką.
Šelo algoritmo variantams būdinga struktūra, kurioje iteruojant per tarpus rikiuojami posekiai, toliau vadinama Šelo algoritmo karkasu,
o karkaso viduje atliekama rikiavimo logika - perėjimu (angl. pass).
Optimizuoto Šelo algoritmo taikomas perėjimas toliau vadinamas įterpimo perėjimu.

Dobosiewicz vienas pirmųjų pastebėjo, jog pasitelkiant
Šelo algoritmo karkasą ir pakeitus rikiavimo logiką taip pat galima sukonstruoti pakankamai efektyvų algoritmą \cite{dobosiewicz1980efficient}.
Dobosiewicz taikytas perėjimas yra labai panašus į burbuliuko rikiavimo algoritmo (angl. bubble sort) atliekamas operacijas -
einama iš kairės į dešinę, palyginant ir (jei reikia) sukeičiant elementus vietomis, todėl
šis perėjimas dažniausiai vadinamas burbuliuko perėjimu (angl. bubble pass) \cite{sedgewick1996analysis}.
Jo pseudokodas pateikiamas \ref{alg:bubble_pass} algoritme.

\begin{algorithm}[H]
  \caption{Burbuliuko perėjimas}\label{alg:bubble_pass}
  \begin{algorithmic}[1]
    \For {$i\gets 0$ \textbf{to} $N-gap-1$}
      \If {$S[i] > S[i+gap]$}
        \State $swap(S[i], S[i+gap])$
      \EndIf
    \EndFor
  \end{algorithmic}
\end{algorithm}

Burbuliuko metodą galima nežymiai patobulinti, suteikiant jam daugiau simetrijos ir atliekant perėjimą
tiek iš kairės į dešinę, tiek iš dešinės į kairę.
Tokiu būdu dešinėje esantys elementai greičiau pasieks savo galutinę poziciją.
Šis metodas primena kokteilio purtymą, todėl literatūroje dažnai vadinamas kokteilio rikiavimu (angl. cocktail sort).
Šio algoritmo idėjas integravus į Šelo algoritmo karkasą taip pat gaunamas gana efektyvus algoritmas \cite{incerpi1986practical}.
Jo taikomas perėjimas toliau vadinamas supurtymo perėjimu (angl. shake pass), o šio perėjimo pseudokodas yra pateikiamas \ref{alg:shake_pass} algoritme.

\begin{algorithm}[H]
  \caption{Supurtymo perėjimas}\label{alg:shake_pass}
  \begin{algorithmic}[1]
    \For {$i\gets 0$ \textbf{to} $N-gap-1$}
      \If {$S[i] > S[i+gap]$}
        \State $swap(S[i], S[i+gap])$
      \EndIf
    \EndFor

    \For {$i\gets N-gap-1$ \textbf{to} $0$}
      \If {$S[i] > S[i+gap]$}
        \State $swap(S[i], S[i+gap])$
      \EndIf
    \EndFor
  \end{algorithmic}
\end{algorithm}

Dar viena burbuliuko algoritmo modifikacija yra mūrijimo rikiavimas (angl. brick sort) \cite{habermann1972parallel}.
Šio algoritmo perėjimo idėja - išrikiuoti visas nelyginių/lyginių indeksų gretimų elementų poras,
o tada atlikti tą patį visoms lyginių/nelyginių indeksų gretimų elementų poroms.
Šią idėją nesunkiai galima pritaikyti ir Šelo algoritmo karkaso viduje, kintamuoju pakeitus originaliame algoritme taikytą tarpą $1$ \cite{lemke1994performance}.
Šis perėjimas toliau vadinamas mūrijimo perėjimu (angl. brick pass), o jo pseudokodas yra pateikiamas \ref{alg:brick_pass} algoritme.

\begin{algorithm}[H]
  \caption{Mūrijimo perėjimas}\label{alg:brick_pass}
  \begin{algorithmic}[1]
    \For {$i\gets gap$ \textbf{to} $N-gap-1$ \textbf{step} $2*gap$}
      \If {$S[i] > S[i+gap]$}
        \State $swap(S[i], S[i+gap])$
      \EndIf
    \EndFor

    \For {$i\gets 0$ \textbf{to} $N-gap-1$ \textbf{step} $2*gap$}
      \If {$S[i] > S[i+gap]$}
        \State $swap(S[i], S[i+gap])$
      \EndIf
    \EndFor
  \end{algorithmic}
\end{algorithm}

\section{Eksperimentinė Šelo algoritmo analizė}

Norint paruošti greitai veikiantį Šelo algoritmo variantą arba taisykles tokiam algoritmui gauti, vertinga žinoti, kodėl vieni variantai veikia greičiau nei kiti.
Kursiniame projekte buvo pastebėta, jog Šelo algoritmo variantų atliekamų operacijų skaičius ne visada koreliuoja su veikimo laiku.
Dėl šiuolaikinių kompiuterių veikimo subtilybių algoritmai, kurie atlieka daugiau palyginimo ir priskyrimo operacijų,
kai kuriais atvejais gali veikti greičiau, nei operacijų atžvilgiu optimalesni algoritmai.
Šiame skyriuje siekiama nustatyti, kokie veiksniai labiausiai įtakoja Šelo algoritmo veikimo laiką.

Šiuolaikinių kompiuterių architektūros yra labai sudėtingos ir tai apsunkina teorines veikimo laiko prognozes.
Tai lemia įvairios šiuolaikinių kompiuterių architektūrose pasitelkiamos strategijos:
instrukcijų vykdymas ne iš eilės, duomenų saugojimas kelių lygių talpykloje, šakų nuspėjimas, etc.
Jei duotas algoritmas netinkamai išnaudoja šias mašinos galimybes, praktinis jo efektyvumas gali stipriai nukentėti.
Todėl bene geriausias būdas nustatyti tikėtiną praktinį algoritmo efektyvumą yra atlikti eksperimentus ir stebėti mašinos veikimą.
Žinoma, tokiu būdu gauti rezultatai priklauso nuo duotos mašinos techinių parametrų ir įvairių kitų veiksnių, tačiau didžioji dalis
šiuolaikinių kompiuterių pasitelkia tas pačias strategijas, tad atliekant kelių algoritmų veikimo palyginimą skirtinguose kompiuteriuose,
santykiniai rezultatų skirtumai neturėtų reikšmingai skirtis.  

\subsection{Veikimo laiko ir atliekamų operacijų tyrimas}

Pirmiausia buvo nutarta pamatuoti kelių skirtingų Šelo algoritmo variantų veikimo laiką ir atliekamas operacijas, siekiant nustatyti kaip tarpų sekos įtakoja šiuos kriterijus.
Vykdant eksperimentus buvo nuspręsta tirti Šelo algoritmo veikimą rikiuojant 64 elementus.
Tai pakankamai svarbus scenarijus, kadangi jis tokiu principu dažnai pasitelkiamas hibridiniuose rikiavimo algoritmuose \cite{golangsort,bzip2sort}.
Taip pat tokio dydžio duomenys lengvai telpa į procesoriaus talpyklą, kas palengvina veikimo laiko analizę.
Šiam eksperimentų etapui buvo pasirinkti du Šelo algoritmo variantai, kur pirmasis naudoja tarpų seką $\{1\}$ kas prilygsta rikiavimui įterpimu, o antrasis naudoja sutrumpintą Ciura tarpų seką $\{57,23,10,4,1\}$.

Eksperimentai buvo atliekami naudojant kompiuterį su 2.70 GHz Intel(R) Core(TM) i7-10850H procesoriumi, 32 GB operatyviosios atminties ir Windows 11 OS.
Tyrimui reikalinga programinė įranga yra prieinama tik Linux OS vartotojams, tad eksperimentai buvo vykdomi WSL aplinkoje su g++ 9.3 kompiliatoriumi naudojant \verb|-O2| optimizacijos lygmenį.
Reikia pastebėti, jog WSL veikia virtualioje mašinoje, tad tai galėjo paveikti gautus rezultatus.
Kadangi praktinis efektyvumas reikšmingai priklauso nuo konkrečios implementacijos, prieduose yra pateikiama eksperimentams naudota Šelo algoritmo implementacija C++ kalba.
Visi eksperimentai buvo vykdomi 5000000 kartų rikiuojant atsitiktinius sveikaskaitinius duomenis.

Pagal \ref{experiment_results_64} lentelėje matomus rezultatus galima pastebėti, jog
Šelo algoritmas su Ciura tarpų seka atliko žymiai mažiau operacijų, tačiau taip pat veikė reikšmingai lėčiau nei variantas su tarpų seka  $\{1\}$.
Šiuo atveju rezultatai yra visiškai neintuityvūs, tačiau aiškiai pastebima, jog atliekamos operacijos ir veikimo laikas nekoreliuoja.
Norint juos paaiškinti, reikia surinkti daugiau duomenų. 

\begin{table}[H]
  \caption{Eksperimentų rezultatai matuojant veikimo laiką ir operacijas, kai $N = 64$}
  \label{experiment_results_64}
  \centering
  \begin{tabular}{@{}llll@{}}
  Tarpų seka            & palyginimai       & priskyrimai      & laikas (ciklais) \\ \midrule
  $\{1\}$               & 1067              & 1126             & 2544                  \\
  Ciura                 & 403               & 439              & 3873                  \\ \bottomrule
  \end{tabular}
\end{table}

\subsection{Šakų nuspėjimo tyrimas}

Šiuolaikiniai kompiuteriai dažniausiai suteikia galimybes stebėti rodiklius, kurie labiausiai įtakoja veikimo laiką.
Tam yra pasitelkiami atskiri registrai, kuriuose saugomas pvz. neatspėtų šakų skaičius.
Kadangi rankiniu būdu tikrinti registrų reikšmes yra gana sudėtinga, buvo pasirinkta esminių rodiklių stebėjimui naudoti \verb|perf| profiliuotoją.
Kadangi \verb|perf| stebi visą programos veikimo laikotarpį, atliekant matavimus pirmiausia buvo išmatuojama kiek operacijų, ciklų ir pan. reikia vien duomenų generavimui,
vėliau juos atimant iš rodiklių, gautų atliekant rikiavimą.

Naudojant \verb|perf| surinkti duomenys pateikiami \ref{perf_results_64} lentelėje.
Kai kurie šiuo atveju neesminiai kriterijai nėra pateikiami, kadangi juos geriau atspindi kombinuoti kriterijai
(pvz. neverta pateikti viso atliktų šakų ir neatspėtų šakų, kai galima pateikti neatspėtų šakų santykį).
Reikia pastebėti, jog instrukcijos įvykdomos per ciklą iš dalies priklauso nuo procesoriaus gebėjimo atspėti šaką, kadangi jos neatspėjus tenka atstatyti prieš spėjimą buvusią būseną,
kas priklausomai nuo procesoriaus užtrunka nuo 10 iki 30 ciklų.
Taip pat skirtingų variantų atliekamos instrukcijos nėra vienodai prasmingos - su tarpu 1 norint perstumti elementą per 3 pozicijas reikės atlikti daugiau instrukcijų,
nei tą patį atliekant su tarpu 3, nors galutinis rezultatas bus toks pats.
Tad vien instrukcijos per ciklą neduoda pilno vaizdo apie rikiavimo spartą ir į tai būtina atsižvelgti.
Analizuojant gautus rezultatus galima pastebėti, kad variantas su tarpų seka $\{1\}$ turi apytiksliai 6 kartus mažesnį neatspėtų šakų santykį bei įvykdo apytiksliai 3 kartus daugiau instrukcijų per ciklą.
Todėl, nors jis ir nėra efektyvus teorine prasme (atlieka daug palyginimų ir priskyrimų), praktikoje jis veikia reikšmingai greičiau, kadangi geriau išnaudoja mašinos galimybes.
Tiesa, rikiuojant sudėtingus duomenų tipus variantas su Ciura tarpų seka turėtų gauti palankesnius veikimo laiko rezultatus, kadangi atlieka mažiau operacijų.

\begin{table}[H]
  \caption{Rezultatai gauti naudojant perf, kai $N = 64$}
  \label{perf_results_64}
  \centering
  \begin{tabular}{@{}lll@{}}
  Tarpų seka            & instrukcijos/ciklai     & neatspėtos šakos \\ \midrule
  $\{1\}$               & 2.35                    & 3.44\%           \\
  $\{57,23,10,4,1\}$    & 0.71                    & 21.30\%          \\ \bottomrule
  \end{tabular}
\end{table}


Pirmiausia reikėtų nustatyti, nuo ko priklauso šakų atspėjamumas naudojant šias tarpų sekas.
Reikia pastebėti, jog rikiavimas įterpimu yra vienas palankiausių $O(n^2)$ algoritmų šakų nuspėjimui
ir rikiuojant neatspėjama $O(n)$ šakų \cite{biggar2005sorting}.
Tai lemia kelios priežastys: išorinio ciklo sąlyga yra lengvai nuspėjama, kadangi ji bus patenkinta tik perėjus visus elementus;
vidiniame cikle pirmiausia tikrinama, ar nepasiekta rikiuojamų duomenų pradžia (tai teisinga tik blogiausiu atveju),
o kita šaka priklauso nuo elementų palyginimo rezultato (sunkiausiai nuspėjama, kadangi priklauso nuo duomenų).
Reikia paminėti, jog rikiavimo įterpimu vidinis ciklas įprastai yra vykdomas keletą iteracijų (norint perstumti elementą per $n$ pozicijų, reikia atlikti tiek pat iteracijų)
ir todėl elementų palyginimo šaka yra pakankamai lengvai nuspėjama.
Šelo algoritmo šakų nuspėjamumas priklauso nuo naudojamos tarpų sekos, tačiau jis įprastai būna reikšmingai prastesnis nei rikiavimo įterpimu \cite{biggar2005sorting}.
Biggar et al. pastebi, jog su Gonnet tarpų seka Šelo algoritme per vieną iteraciją kiekvienas elementas yra pastumiamas apytiksliai per $0.9744 * h$ \cite{biggar2008experimental}.
Tai reiškia, kad vidinis ciklas, kuriame vykdomas rikiavimas įterpimu su tam tikru tarpu, vidutiniškai atlieka mažiau nei vieną iteraciją, kas lemia, jog
vidiniame cikle vykdomo elementų palyginimo šaką yra sudėtinga nuspėti.

Taip pat verta pastebėti, jog kiekvienas papildomas tarpas padidina neatspėtų šakų santykį.
Kaip pastebima \cite{biggar2008experimental}, Šelo algoritmo neatspėtų šakų skaičius priklauso nuo atliekamų perėjimų skaičiaus.
To paaiškinimas yra gana paprastas - rikiavimas įterpimu sukelia $O(n)$ neatspėtų šakų,
tad vienas perėjimas, kuriame atliekamas posekio rikiavimas įterpimu taip pat sukels $O(n)$ neatspėtų šakų \cite{biggar2008experimental}.
Tad $p$ perėjimų atliekantis Šelo algoritmas viso sukels $O(np)$ neatspėtų šakų.

Kadangi prieš tai nagrinėtos tarpų sekos pastebimai skiriasi, buvo pasirinkta ištirti tarpų sekas, kurios yra gana paprastos ir tokio paties ilgio: $\{1, 16 \}$, $\{1, 32 \}$, $\{1, 48 \}$.
Atliekant eksperimentus gauti rezultatai pateikiami \ref{perf_results2_64} lentelėje.
Remiantis gautais rezultatais, geriausią šakų nuspėjamumą turi tarpų seka $\{1, 48 \}$.
Taip pat galima pastebėti, kaip mažėjant neatspėtų šakų skaičiui auga instrukcijų per ciklą skaičius bei didėja atliekamų operacijų skaičius.
Nors su tarpų seka $\{1, 48 \}$ šakos nuspėjamos tiksliau bei atliekama daugiau instrukcijų per ciklą, su tarpų seka $\{1, 32 \}$ veikimo laikas yra geresnis.
Tad vien šakų nuspėjimo tikslumas ir instrukcijų įvykdomų per ciklą kiekis pilnai nenusako veikimo spartos. 

\begin{table}[H]
  \caption{Eksperimentų rezultatai, kai $N = 64$}
  \label{perf_results2_64}
  \centering
  \begin{tabular}{@{}lllllll@{}}
  Tarpų seka             & instrukcijos/ciklai     & neatspėtos šakos  & palyginimai       & priskyrimai      & laikas (ciklais) \\ \midrule
  $\{1, 16 \}$            & 1.29                    & 9.94\%            & 578               & 656              & 2822                  \\
  $\{1, 32 \}$            & 1.74                    & 6.19\%            & 753               & 823              & 2579                  \\
  $\{1, 48 \}$            & 1.93                    & 5.20\%            & 825               & 888              & 2618                  \\ \bottomrule
  \end{tabular}
\end{table}

Vertinant gautus rezultatus, taip pat pastebima, jog variantai su tarpų sekomis $\{1, 48 \}$, $\{1, 32 \}$, $\{1, 16 \}$ lenkia variantą
su Ciura tarpų seka vertinant veikimo laiką ir beveik prilygsta variantui su tarpų seka $\{1\}$.
Žinoma, tam pasiekti jie atlieka daugiau operacijų, nei variantas su Ciura tarpų seka, tačiau taip pat atlieka reikšmingai mažiau operacijų nei variantas su tarpų seka $\{1\}$.
Tad šiuo atveju pasiekiamas tam tikras balansas tarp atliekamų operacijų ir veikimo laiko.

Nagrinėjamu atveju galima bendrai įvertinti pasirinktų tarpų sekų veikimą.
Pavyzdžiui, tarpų seka $\{ 1, 48 \}$, pirmame perėjime atliks 16 iteracijų, kadangi vykdymas pradedamas nuo indekso $48$.
Panašia logika, tarpų seka $\{1, 32 \}$ pirmame perėjime atliks 32 iteracijas.
Šios tarpų sekos vidinį ciklą visada vykdys maksimaliai vieną kartą, kadangi pirmo perėjimo tarpai yra pakankamai dideli ir rikiuojamo posekio ilgis visada bus 2.
Tarpų seka $\{1, 16 \}$ pirmame perėjime atliks 48 iteracijas, tačiau rikiuojamo posekio ilgis didės kas 16 iteracijų.
Remiantis tuo, įmanoma apskaičiuoti maksimaliai pirmame perėjime atliekamų palyginimų skaičių kiekvienai tarpų sekai:
$\{1, 48 \}$ - $16 * 1 = 16$, $\{1, 32 \}$ - $32 * 1 = 32$, $\{1, 16 \}$ - $16 * 1 + 16 * 2 + 16 * 3 = 96$.
Tad tarpų seka $\{1, 16 \}$ pirmame perėjime gali atlikti 6 kartus daugiau elementų palyginimų, nei tarpų seka $\{1, 48 \}$.

Tiesa, iš pateiktų rezultatų sunku nuspręsti, kaip priklauso elementų palyginimo šakos nuspėjamumas priklausomai nuo tarpo dydžio.
Atlikus preliminarius matavimus rikiuojant vien su tarpais 16, 32 ir 48 nebuvo pastebėta reikšmingų skirtumų (visais atvejais neatspėtų šakų buvo apie 17\%).
Tad galima teigti, jog tarpų sekų $\{1, 48 \}$ ir $\{1, 32 \}$ šakų nuspėjamumo rezultatai yra geresni, nes jos pirmame perėjime
mažiau aprikiuoja duomenis ir taip atlieka mažiau elementų palyginimo šakų, kas lemia, jog daugiau rikiavimo atliekama su tarpu 1, kur nuspėjamumas yra geresnis.
Bendrai vertinant šakų nuspėjamumą Šelo algoritmu rikiuojant nedidelius duomenų dydžius,
galima teigti, jog bendras šakų nuspėjamumas priklauso ne tik nuo naudojamų perėjimų kiekio, tačiau ir nuo
pasirinktų tarpų dydžio, kadangi nuo jo priklauso, kiek elementų palyginimų (tuo pačiu ir šakų) bus atlikta su tam tikru tarpu.

\section{Šelo algoritmo variantų efektyvumo kriterijai}

Įprastai praktinis rikiavimo algoritmų efektyvumas yra vertinamas matuojant jų atliekamų palyginimų ar priskyrimų skaičių.
Tai yra pakankamai geri kriterijai norint praktiškai įvertinti duoto algoritmo efektyvumą su tam tikrais duomenų dydžiais,
kadangi algoritminis sudėtingumas nurodo tik veikimo laiko augimą priklausomai nuo $N$ ir
neatsižvelgia į konstantas, kurios praktikoje taip pat įtakoja veikimo greitį \cite{biggar2005sorting}.

Tiksliam efektyvumo įvertinimui tinkama matuoti tiek atliekamus palyginimus, tiek atliekamus priskyrimus.
To priežastis yra gana paprasta - rikiuojant duomenis, kurių palyginimas yra sudėtingas (pvz. simbolių eilutes),
algoritmo veikimo laiką stipriau įtakoja jo atliekamų palyginimų skaičiaus.
Analogiškas efektas pastebimas ir rikiuojant duomenis, kurių priskyrimas yra sudėtingas.
Vertinant Šelo algoritmo variantų efektyvumą būtina matuoti tiek atliekamus palyginimus, tiek atliekamus priskyrimus, kadangi
atliekamų palyginimų ir priskyrimų skaičiaus santykis priklauso nuo implementacijos ir augant $N$ nebūtinai artėja prie 1 \cite{Radavičius_Baranauskas_2013}.

Vertinant Šelo algoritmo variantų efektyvumą taip pat būtina atsižvelgti ir į veikimo laiką.
Savaime suprantama, jog į šį kriterijų verta žvelgti pakankamai kritiškai, kadangi jis priklauso nuo konkrečios algoritmo implementacijos,
eksperimentams naudojamos mašinos techninių parametrų ir kompiliatoriaus taikomų optimizacijų lygio.
Tačiau tai bene vienintelis kriterijus, leidžiantis įvertinti realų algoritmo praktinį efektyvumą, kas yra ypač svarbu,
kadangi naudojant šiuolaikinį kompiuterį labai sunku iš anksto nustatyti, kaip greitai algoritmas veiks praktikoje.
Atsižvelgiant į aukščiau pateiktus argumentus, galima teigti, jog
algoritmo veikimo laiko įvertis yra svarbus kriterijus įvertinant praktinį Šelo algoritmo varianto efektyvumą.

Remiantis aukščiau pateiktais argumentais, šiame darbe Šelo algoritmo variantai vertinami pagal
atliekamų palyginimų skaičių, atliekamų priskyrimų skaičių ir veikimo laiką.
Kiekvienas iš šių kriterijų yra pakankamai svarbus įvertinant duoto algoritmo efektyvumą, tad svoriai šiems kriterijams nėra taikomi.

\section{Genetiniai algoritmai}

Paprasčiausias genetinis algoritmas susideda iš individų populiacijos bei atrankos, mutacijos ir rekombinacijos operatorių \cite{simpson1999faster}.
Šiame skyriuje nagrinėjamos šių terminų reikšmės ir genetinių algoritmų veikimo principai.

\subsection{Individų populiacija}

Individu GA kontekste vadinamas potencialus uždavinio sprendinys.
Projektuojant genetinį algoritmą tam tikro uždavinio sprendimui, svarbu tinkamai pasirinkti,
kaip kompiuteriu modeliuoti galimus sprendinius.
Įprastai siekiama sprendinį modeliuoti kuo primityviau, siekiant
palengvinti mutacijos ir rekombinacijos operatorių taikymą.

Individų rinkinys yra vadinamas populiacija ir atspindi uždavinio sprendinių aibę, kuri kinta kiekvieną genetinio algoritmo iteraciją.
Populiacijos dydis dažniausiai pasirenkamas priklausomai nuo sprendžiamo uždavinio,
tad literatūroje nėra konsensuso, kokį populiacijos dydį rinktis bendru atveju.

Duoto sprendinio kokybė yra nustatoma pasitelkiant tikslo funkciją.
Tikslo funkcija dar vadinama kainos arba tinkamumo funkcija, priklausomai nuo sprendžiamo uždavinio tipo.
Tikslo funkcija yra viena svarbiausių genetinio algoritmo dalių,
kadangi kai ji netinkamai parinkta, algoritmas nekonverguos į tinkamą sprendinį arba užtruks labai ilgai.

\subsection{Genetiniai operatoriai}

Esminė GA dalis yra populiacijos genetinės įvairovės užtikrinimas, geriausių individų atranka ir kryžminimasis.
Siekiant užtikrinti šių procesų išpildymą, genetinis algoritmas vykdymo metu
iteratyviai atnaujina esamą populiaciją taikydamas atrankos, rekombinacijos ir mutacijos operatorius.

Atrankos operatorius grąžina tinkamiausius populiacijos individus, kuriems yra leidžiama susilaukti palikuonių taikant rekombinacijos operatorių.
Dažniausiai atranka vykdoma atsižvelgiant į populiacijos individų tinkamumą, atrenkant ir pateikiant rekombinacijai tuos, kurių tinkamumas yra geriausias.

Rekombinacijos operatorius įprastai veikia iš dviejų tėvinių individų sukurdamas naują individą, kas dažniausiai pasiekiama
tam tikru būdu perkopijuojant tėvų savybes vaikiniam individui.

Mutacijos operatorius veikia modifikuojant pasirinkto individo vieną ar kelias savybes.
Tinkamas chromosomos mutacijos tikimybės parinkimas yra vienas iš svarbiausių sprendimų projektuojant GA,
kadangi nuo mutacijos tikimybės dažnu atveju priklauso populiacijos genetinė įvairovė, o tuo pačiu ir gaunamų sprendinių kokybė.

\section{Genetinis algoritmas Šelo algoritmo variantų generavimui}

Pirmiausia reikėtų aptarti kaip turėtų būti modeliuojamas sprendinys, atspindintis tam tikrą Šelo algoritmo variantą.
Laikysime jog Šelo algoritmo variantą sudaro sąrašas porų $(p, h)$, kur $p$ yra skaičius, atitinkantis vieną iš anksčiau darbe aptartų perėjimų tipų,
o $h$ - tarpas, su kuriuo rikiuojama tame perėjime.
Toliau darbe tokiu būdu modeliuojamas Šelo algoritmo variantas vadinamas individu, o pora $(p, h)$ - genu.
Tiesa, toks modelis neturi jokio funkcionalumo (juo duomenų rikiuoti negalima), tačiau tai nėra sunku išspręsti: pakanka kiekvienam perėjimo tipui
paruošti atitinkamą funkciją, kuri kaip parametrus priima rikiuojamus duomenis ir tarpą su kuriuo rikiuojama.
Tada modeliuojamą Šelo algoritmo variantą galima nesunkiai vykdyti iteruojant jo genų sąrašą ir kiekvienai porai $(p, h)$ iškviečiant funkciją atitinkančią jos tipą ir nurodant tarpą su kuriuo rikiuoti.

Taip pat labai svarbu apibrėžti kaip bus inicializuojami pradiniai sprendiniai, kurie bus naudojami genetinio algoritmo vykdymui.
Parinkti atsitiktinį perėjimo tipą yra nesudėtinga, kadangi pakanka sugeneruoti atsitiktinį skaičių, atitinkantį vieną iš apibrėžtų tipų.
Tuo tarpu greitai sugeneruoti pakankamai efektyvias tarpų sekas yra gana sudėtinga.
Tuo tikslu buvo pasirinkta individų inializacijai naudoti geometrines tarpų sekas, kadangi jas gana nesudėtinga generuoti
ir jos bendru atveju yra pakankamai efektyvios (didelė dalis efektyvių eksperimentiškai gautų tarpų sekų yra geometrinės).
Geometrinių tarpų sekų generavimo eiga yra pateikiama \ref{alg:geometric_gaps} algoritme.
Siekiant padidinti individų genetinę įvairovę, taip pat buvo pasirinkta dalį individų inicializuoti
tarpų sekomis, kurios generuojamos metodu panašiu į geometrinių tarpų sekų generavimą, koeficientą $q$ parenkant atsitiktinai kiekvienam tarpui.
Generuojant geometrines tarpų sekas buvo nuspręsta koeficientą $q$ parinkti atsitiktinai, užtikrinant, jog $1.5 \leq q \leq 7$.
Generuojant atsitiktines tarpų sekas taip pat buvo taikomas panašus principas, tačiau šiuo atveju naudotas toks $q$, kad $1.5 \leq q \leq 12.5$.

\begin{algorithm}[H]
  \caption{Geometrinių tarpų sekų generavimas}\label{alg:geometric_gaps}
  \begin{algorithmic}[1]
    \Procedure{geometric\_gaps}{$n, q$}
      \State let $gaps$ be an empty set
      \State $current \gets 1$
      
      \While{$current < n$}
        \State insert $\lceil current \rceil$ into $gaps$
        \State $current \gets current * q$ 
      \EndWhile

      \State \textbf{return} $gaps$
    \EndProcedure
  \end{algorithmic}
\end{algorithm}

Genetinio algoritmo įgyvendinimui buvo pasirinkta naudoti C++ programavimo kalbą ir openGA biblioteką \cite{mohammadi2017openga}.
C++ buvo pasirinkta dėl veikimo spartos ir patirties sukauptos ruošiant kursinį darbą ir kursinį projektą.
OpenGA biblioteka buvo pasirinkta dėl modernumo ir lygiagretaus vykdymo palaikymo.

Nors kriterijai Šelo algoritmo varianto efektyvumui įvertinti buvo apibrėžti praeitame skyriuje,
reikalinga plačiau aptarti kaip bus nustatoma duoto individo kaina.
Pirmiausia, siekiama, jog gautas algoritmas būtų deterministinis ir visada išrikiuotų duomenis, kadangi tikimybinių rikiavimo algoritmų panaudojamumas yra ribotas.
Todėl būtina po rikiavimo suskaičiuoti rikiuojamų duomenų inversijas ir šį kriterijų minimizuoti.
Taip pat reikia, jog pats inversijų skaičiavimas neužtruktų per ilgai, kadangi tai apsunkintų genetinio algoritmo vykdymą.
Šiuo tikslu buvo nuspręsta inversijų skaičiavimui pasitelkti modifikuotą rikiavimo sąlaja algoritmą, kurio sudėtingumas blogiausiu atveju yra $O(n\,log\,n)$.
Remiantis darbe iškelta hipoteze taip pat siekiama, jog sugeneruoti algoritmai veiktų greitai, todėl
vienas iš esminių kriterijų yra veikimo laikas.
Veikimo laiko matavimams buvo nuspręsta naudoti rikiavimo metu procesoriaus atliekamų ciklų skaičių pasitelkiant \verb|RDTSC| instrukciją.
Taip pat labai svarbu, jog algoritmo veikimo laikas stipriai nepriklausytų nuo rikiuojamų duomenų specifikos, tad 
būtina užtikrinti, jog atliekamų palyginimo ir priskyrimo operacijų skaičius būtų pakankamai mažas.
Operacijų skaičiavimui buvo pasitelkta projektiniame darbe naudota Element klasė, kuri naudojant palyginimo ir priskyrimo operatorių
perkrovimą seka šių operacijų skaičių rikiavimo metu.

Kaip buvo minėta įvade, Šelo algoritmo variantų generavimui buvo pasirinkta naudoti daugiakriterinį genetinį algoritmą.
Kadangi daugiakriteriniame GA svoriai netaikomi, buvo nuspręsta kai kuriems kriterijams taikyti prioritetus.
Tai reiškia, jog vienam iš kriterijų neatitinkant nustatyto apribojimo, kai kurie kiti kriterijai gali būti ignoruojami
tam, kad prioritetinis kriterijus atitiktų apribojimus.
Remiantis aukščiau aptartais tikslais, buvo nuspręsta taikyti prioritetus duomenų inversijoms bei veikimo laikui.
Laikant jog $i$ yra inversijų skaičius, $t$ - veikimo laikas (ciklais),
$c$ - palyginimų skaičius, $a$ - priskyrimų skaičius, o $T$ - tam tikra konstanta,
individo kainos funkcija yra apibrėžiama tokia forma:

\[
  cost(i, t, c, a)=
  \begin{cases}
    (i, \infty, \infty, \infty),& \text{if } i > 0\\
    (i, t, \infty, \infty),& \text{if } t > T\\
    (i, t, c, a), & \text{otherwise}
  \end{cases}
\]

Algoritmai buvo vertinami rikiuojant atsitiktinius sveikaskaitinius duomenis.
Atliekamų matavimų skaičius buvo nustatomas pagal duomenų dydį, kuriam generuojami algoritmai (jei duomenų dydis didelis, atliekama mažiau matavimų).
Pirmiausia dėl to, jog su didesniais duomenų dydžiais GA neužtruktų per ilgai, o tuo pačiu ir tam,
jog rezultatai gauti su mažesniais duomenų dydžiais būtų tikslesni.

Siekiant pagerinti gautų rezultatų kokybę buvo įgyvendinta individų atranka.
Šiuo tikslu buvo atmetami individai, kurių vidutinis duomenų inversijų skaičius po rikiavimo didesnis nei $frac{N}{10}$.
Taip pat buvo atmetami individai, kurių vidutinis veikimo laikas buvo didesnis nei $2\,T$.

Individų mutacija buvo įgyvendinta pasirenkant atsitiktinį individo geną ir atsitiktinai pakeičiant jo perėjimo tipą kuriuo nors kitu.
Individų rekombinacija buvo vykdoma tolygia strategija, kur dviejų tėvų genai turi vienodą tikimybę
būti perduoti vaikiniam individui.
Siekiant išvengti netinkamų sprendinių, rekombinacijos operatoriumi gauto naujo individo genai buvo išrikiuojami pagal tarpą naudojamą rikiavimui.

Atlikus pradinius eksperimentus ir preliminariai įvertinus gautų sprendinių tinkamumą buvo pasirinkta GA taikyti tokius parametrus:
populiacija - $250$, mutacijos tikimybė - $0.1$, rekombinuojama populiacijos dalis - $0.4$.
GA buvo nurodyta sustoti įvykdžius 100 iteracijų.

\section{Šelo algoritmo variantų generavimas}

Šiame skyriuje siekiama sugeneruoti Šelo algoritmo variantus,
kurie leistų rikiuoti duomenis greičiau nei žinomi variantai.
Genetinio algoritmo esminiai veikimo principai buvo apibrėžti praeitame skyriuje, tačiau
konstantos $T$, apibrėžiančios apribojimus veikimo laikui, reikšmė nebuvo apibrėžta.
Iš esmės $T$ reikšmė priklauso nuo duomenų dydžio - jei rikiuojama daugiau elementų, reikėtų pasirinkti didesnę $T$ reikšmę.
Natūralu būtų siekti apibrėžti funkciją $f$, kuri atitinkamam duomenų dydžiui grąžintų reikiamą $T$.
Tačiau tam reikėtų funkcijos, nusakančios apytikslį įvairių Šelo algoritmo variantų vidutinį veikimo laiką.
Kadangi tai įgyvendinti yra gana sudėtinga, buvo pasirinktas paprastesnis metodas - kiekvienam naudojamam duomenų dydžiui ištirti
Šelo algoritmo su Ciura tarpų seka veikimo laiką ir laikyti, jog tai yra $T$.

\subsection{Šelo algoritmo variantų generavimas, kai $N = 128$}

Šiame poskyryje siekiama sugeneruoti Šelo algoritmo variantus,
kurie leistų rikiuoti nedidelius duomenų dydžius greičiau nei žinomi variantai.
Algoritmų generavimui pasirinkta naudoti $T = 9000$.
Genetinis algoritmas buvo įvykdytas 50 kartų, viso buvo sugeneruota 890 skirtingų variantų.

Atsižvelgiant į surinktus duomenis apie veikimo laiką ir atliekamas operacijas buvo atrinkti 3 tinkamiausi variantai: A1, A2 ir A3.
Kadangi gauti algoritmai dažniausiai naudoja įterpimo perėjimą, toliau glaustumo dėlei bus nusakomos tik tarpų sekos ir tarpai, su kuriais naudojami kitokie perėjimai.

\begin{itemize}
  \item A1: $1, 6, 52$, su didžiausiu tarpu naudojamas burbuliuko perėjimas
  \item A2: $1, 7, 92$, su didžiausiu tarpu naudojamas supurtymo perėjimas
  \item A3: $1, 10, 76 $, su didžiausiu tarpu naudojamas burbuliuko perėjimas
\end{itemize}

Galima pastebėti tendenciją, jog visi gauti algoritmai naudoja ne įterpimo perėjimą su didžiausiu tarpu.
Kaip buvo minėta viename iš praeitų skyrių, su dideliais (santykinai duomenų dydžiui) tarpais atlikti įterpimo perėjimą nėra prasminga,
tad panašu, jog kainos funkcija taip pat privedė individus prie šios optimizacijos taikymo.

\subsection{Šelo algoritmo variantų generavimas, kai $N = 1024$}

Šiame poskyryje siekiama sugeneruoti Šelo algoritmo variantus,
kurie leistų rikiuoti vidutinius duomenų dydžius greičiau nei žinomi variantai.
Algoritmų generavimui pasirinkta naudoti $T = 125000$.
Genetinis algoritmas buvo įvykdytas 50 kartų, viso buvo sugeneruota 690 skirtingų variantų.

Atsižvelgiant į surinktus duomenis apie veikimo laiką ir atliekamas operacijas buvo atrinkti 3 tinkamiausi variantai: B1, B2 ir B3. 
Kadangi gauti algoritmai naudoja tik įterpimo perėjimus, toliau glaustumo dėlei bus nusakomos tik jų tarpų sekos.

\begin{itemize}
  \item B1: $1, 4, 17, 40, 162$
  \item B2: $1, 5, 19, 155$
  \item B3: $1, 8, 26, 97 $
\end{itemize}

Galima pastebėti, jog gautų algoritmų tarpų sekos yra žymiai trumpesnės, nei įprastai sutinkamų Šelo algoritmo variantų.
Kaip pastebima \cite{Radavičius_Baranauskas_2013}, vertinant veikimo laiką dažnai tinkamesnės būna geometrinės tarpų sekos, kur $q$ yra didesnis.
Reikia pastebėti, kad kuo didesnis $q$, tuo mažiau perėjimų bus atliekama tam tikro duomenų dydžio išrikiavimui,
o kiekvienas papildomas perėjimas didina neatspėtų šakų santykį bei reikalauja papildomo darbo.  

\subsection{Šelo algoritmo variantų generavimas, kai $N = 8192$}

Šiame poskyryje siekiama sugeneruoti Šelo algoritmo variantus,
kurie leistų rikiuoti didelius duomenų dydžius greičiau nei žinomi variantai.
Algoritmų generavimui pasirinkta naudoti $T = 1500000$.
Genetinis algoritmas buvo įvykdytas 20 kartų, viso buvo sugeneruoti 322 skirtingi variantai.

Atsižvelgiant į surinktus duomenis apie veikimo laiką ir atliekamas operacijas buvo atrinkti 3 tinkamiausi variantai: C1, C2 ir C3.
Kadangi gauti algoritmai dažniausiai naudoja įterpimo perėjimą, toliau glaustumo dėlei bus nusakomos tik tarpų sekos ir tarpai, su kuriais naudojami kitokie perėjimai.

\begin{itemize}
  \item C1: $1, 4, 11, 25, 104, 264, 615, 1794$, su antru pagal dydį tarpu naudojamas supurtymo perėjimas
  \item C2: $1, 4, 11, 25, 104, 356, 1152, 1794$, su antru pagal dydį tarpu naudojamas burbuliuko perėjimas
  \item C3: $1, 6, 19, 53, 187, 760 $
\end{itemize}

\section{Šelo algoritmo variantų efektyvumo tyrimo aplinka}

\subsection{Duomenų rinkiniai}

Norint tinkamai įvertinti įvairių Šelo algoritmo variantų efektyvumą, yra būtina atlikti eksperimentus naudojant
įvairius duomenų rinkinius.
Idealiu atveju, tyrime taip pat naudojami skirtingi duomenų tipai (skaičiai, simbolių eilutės, etc.), kas leidžia įvertinti 
atliekamų palyginimų ir priskyrimų įtaką rikiavimo laikui.
Šiame darbe buvo pasirinkta naudoti sveikaskaitinius duomenis, generuojamus juos išdėstant 6 skirtingais būdais.
Šie duomenų išsidėstymo būdai yra apibrėžiami žemiau.

Dažniausiai literatūroje tiriant rikiavimo algoritmų efektyvumą yra sutinkami atsitiktiniai išsidėstę duomenys.
Šiame darbe buvo pasirinkta naudoti kelis šio duomenų išsidėstymo variantus.
Variantas \verb|shuffled_int| pirmiausia sugeneruoja sąrašą pavidalo $\{0, \dots, size-1\}$,
tada naudojant \verb|std::shuffle| funkciją šis sąrašas yra išmaišomas.
Reikia paminėti, jog \verb|std::shuffle| garantuoja, kad ją įvykdžius elementų tvarka yra atsitiktinė ir kiekvienas
skirtingas įmanomas elementų derinys turi vienodą tikimybę pasirodyti galutiniame sąraše.

Variantas \verb|shuffled_mod_sqrt| pirmiausia sugeneruoja sąrašą, kur kiekviena reikšmė yra formos $a \pmod{\lfloor \sqrt{size} \rfloor}$ ir $a \in \{0, \dots, size-1\}$,
o tada naudojant \verb|std::shuffle| šis sąrašas yra išmaišomas.
Šis duomenų rinkinys leidžia įvertinti, kaip veikia rikiavimo algoritmai, kai yra pakankamai daug dublikatų.

Variantas \verb|descending| sugeneruoja sąrašą pavidalo $\{size-1, \dots, 0 \}$,
t.y. elementai yra išdėstomi mažėjimo tvarka.
Šiuo atveju laikome, jog algoritmai rikiuoja didėjimo tvarka, tad toks duomenų rinkinys leidžia
įvertinti, kaip veikia tiriami rikiavimo algoritmai, kai duomenys yra išdėstyti nepalankia (atvirkščia) tvarka.
Tuo pačiu reikia pridurti, jog rinkinys, kur elementai išdėstyti didėjimo tvarka, šio tyrimo kontekste neturėtų prasmės ir todėl nėra įtraukiamas,
kadangi visiems Šelo algoritmo variantams tai yra geriausias atvejis (nereikia vykdyti jokių sukeitimų).
Lygiai tuo pačiu principu buvo pasirinkta neįtraukti ir duomenų rinkinio, kur visi elementai yra lygūs.

Variantas \verb|partially_sorted| sugeneruoja sąrašą pavidalo $\{0, \dots, size-1\}$,
tada naudojant \verb|std::shuffle| jį išmaišo, o po to dalinai jį išrikiuoja pasitelkiant \verb|std::partial_sort| funkciją.
Šiuo atveju dalinis rikiavimas atliekamas tokiu būdu, kad pirma pusė elementų yra išrikiuoti, o antra pusė elementų yra išdėstyti atsitiktine tvarka.
Šis duomenų rinkinys leidžia įvertinti, kaip veikia rikiavimo algoritmai, kai į vieną yra sujungiami du sąrašai, kur pirmas sąrašas yra išrikiuotas, o antras ne.
Galima nesunkiai įsivaizduoti tokio duomenų išsidėstymo pasitaikymo atvejį praktikoje - tarkime, programa turi duomenis kurie yra išrikiuoti,
gauna daugiau duomenų, šiuos sąrašus sujungia ir vėl išrikiuoja, siekiant išlaikyti jų tvarką.

Variantas \verb|merge| sugeneruoja du sąrašus pavidalo $\{0, \dots, \lfloor size/2 \rfloor\}$ ir juos sujungia į vieną.
Šis duomenų rinkinys leidžia įvertinti, kaip veikia rikiavimo algoritmai, kai vieną sąrašą sudaro du išrikiuoti nuoseklūs posekiai.
Praktinis šio duomenų rinkinio naudojimo atvejis yra gana panašus į \verb|partially_sorted| duomenų rinkinio.
Reikia pastebėti, jog šis atvejis su praktikoje sutinkamais duomenimis yra gana dažnas, dėl to pvz.
Timsort algoritmas, kuris sugeba išnaudoti duomenyse pasitaikančius išrikiuotus posekius efektyvesniam rikiavimui, yra taip plačiai naudojamas \cite{auger2015merge}.

Variantas \verb|push_min| sugeneruoja sąrašą pavidalo $\{1, \dots, size-1, 0\}$, t.y. visi elementai, išskyrus paskutinį, yra išrikiuoti.
Šis duomenų rinkinys leidžia įvertinti, kaip veikia rikiavimo algoritmai, kai į išrikiuoto sąrašo galą yra pridedamas dar vienas elementas ir siekiama vėl užtikrinti duomenų tvarką.
Šis atvejis yra gana nepalankus, kadangi neišrikiuotas yra tik vienas elementas, tačiau jį yra būtina perstumti į kitą sąrašo galą.
Galima nesunkiai įsivaizduoti tokio duomenų išsidėstymo pasitaikymo atvejį praktikoje, ypač jei siekiant išlaikyti duomenų tvarką dėl ribotos standartinės bibliotekos ar
žinių trūkumo pasirenkama naudoti ne prioritetinę eilę, o duomenis kaskart išrikiuoti.

\subsection{Tyrimo metodika}

Atliekant tyrimą buvo pasirinkta įvertinti sugeneruotų ir geriausiai žinomų Šelo algoritmo variantų efektyvumą.
Tuo tikslu buvo pasirinkta gautus variantus lyginti su optimizuotu Šelo algoritmu naudojant šias tarpų sekas:

\begin{itemize}
  \item Ciura: $1, 4, 10, 23, 57, 132, 301, 701$ \cite{ciura2001best}
  \item Tokuda: $1, 4, 9, 20, 46, 103, 233, 525, \ldots $ \cite{tokuda1992}
  \item Sedgewick: $1, 5, 19, 41, 109, 209, 505, 929, \ldots$ \cite{SEDGEWICK1986159}
\end{itemize}

Kadangi Ciura seka yra baigtinė, didesnių duomenų dydžių rikiavimui ji buvo pratęsta pasitelkiant rekursyvią formulę $h_{k}=\lfloor 2.25h_{k-1}\rfloor$.
Sedgewick ir Tokuda sekos yra begalinės, tad jos buvo sutrumpintos taip, jog gauta seka būtų ilgiausia įmanoma seka, kurios visi elementai mažesni už 8192 (maksimalų tirtą duomenų dydį).

Kadangi darbe buvo generuojami algoritmai, leidžiantys efektyviai rikiuoti tris skirtingus duomenų dydžius, tyrimą sudaro trys algoritmų rinkiniai.
Pirmą rinkinį sudaro A1, A2, A3 algoritmai ir literatūroje pateikti variantai, antrą rinkinį sudaro B1, B2, B3 algoritmai ir literatūroje pateikti variantai,
trečią rinkinį C1, C2, C3 algoritmai ir literatūroje pateikti variantai.
Su kiekvienu iš šių rinkinių eksperimentai atliekami naudojant tris skirtingus duomenų dydžius: $\frac{N}{2^2}$, $\frac{N}{2}$, $N$.
Čia $N$ yra duomenų dydis, su kuriuo pasitelkiant GA buvo sugeneruota dalis to rinkinio algoritmų.

Atliekant efektyvumo tyrimą buvo pasirinkta kiekvienai algoritmo ir duomenų rinkinio porai
atlikti matavimus tol, kol praeis 10 sekundžių.
Tokiu būdu atliekamų matavimų skaičius automatiškai prisitaiko prie duomenų dydžio
ir rezultatai gauti su mažesniais duomenų dydžiais yra tikslesni.
Siekiant padidinti rezultatų tikslumą, kiekviena algoritmo ir duomenų rinkinio pora
prieš atliekant matavimus buvo 2 sekundes apšildoma atliekant rikiavimą ir nefiksuojant rezultatų.
Tai leido apšildyti procesoriaus talpyklas ir sumažinti tikimybę,
jog procesoriaus veikimo dažnis ženkliai pasikeis atliekant matavimus.

Kiekvienai algoritmo ir atsitiktinio duomenų rinkinio porai taip pat buvo naudojama ta pati pradinė reikšmė,
kuri inicializuoja \verb|std::shuffle| naudojamą atsitiktinių skaičių generatorių.
Tad iš esmės kiekvienas algoritmas tam tikrame duomenų rinkinyje turėtų rikiuoti tokius pat pradinius duomenis.

Siekiant jog gauti rezultatai būtų statistiškai reikšmingi, buvo pasirinkta naudoti tarpkvartilinio diapazono (angl. interquartile range) metodą.
Šis metodas leidžia aptikti nuokrypius, kas leidžia nustatyti nenumatytų veiksnių įtaką gautiems rezultatams.
Tai ypač svarbu matuojant veikimo laiką, kadangi jį labiausiai paveikia išorinių veiksnių įtaka.
Taip pat tarpkvartilinis diapazonas nurodo rezultatų sklaidą aplink medianą,
kas leidžia nustatyti atliktų matavimų paklaidą.

\subsection{Tyrimo aplinka}

Eksperimentų vykdymui buvo naudojamas kompiuteris su 2.70 GHz Intel(R) Core(TM) i7-10850H procesoriumi,
32 GB operatyviosios atminties ir Windows 11 operacine sistema.
Efektyvumo tyrimas buvo įgyvendintas C++ kalba su MSVC 19.16.27043 kompiliatoriumi.


\section{Šelo algoritmo variantų efektyvumo tyrimas}

\subsection{Efektyvumas priklausomai nuo duomenų rinkinio}

\subsubsection{Veikimo laikas}

Remiantis \ref{img:cycles_1024_1024} pav. rezultatais, mažiausiai palankus veikimo laiko prasme yra duomenų rinkinys \verb|shuffled|.
Duomenų rinkinys \verb|shuffled| iš tiriamų rinkinių turi didžiausią entropiją, kadangi jį sudaro atsitiktine tvarka išdėstyti ir neturintys dublikatų duomenys.
Tokį duomenų rinkinį sudėtinga rikiuoti, kadangi jau išrikiuotų posekių egzistavimo tikimybė yra gana maža ir
kiekvienas elementas turi vienodą tikimybę būti bet kurioje iš galimų pozicijų.
Rinkinys \verb|shuffled_mod_sqrt| taip pat yra atsitiktinai išdėstomas ir todėl gana nepalankus, nors 
pastebimi veikimo laikai yra geresni nei su rinkiniu \verb|shuffled|.
% TODO: pridet kazka?

Veikimo laiko atžvilgiu labiausiai palankūs yra rinkiniai \verb|merge| ir \verb|push_min|.
Šie rinkiniai pasižymi tuo, jog yra dalinai išrikiuoti (\verb|merge| sudaro du išrikiuoti sąrašai, \verb|push_min| turi tik vieną neišrikiuotą elementą).
Šelo algoritmas (o tuo pačiu ir tiriami variantai) yra adaptyvus (dalinai išrikiuotus duomenis rikiuoja greičiau),
tad šiuo atveju galima pastebėti šios savybės teikiamą naudą.

Su visais duomenų rinkiniais yra pastebimas geresnis GA sugeneruotų variantų veikimo laikas lyginant juos su literatūroje pateiktais variantais. 
Bene didžiausi rezultatų skirtumai pastebimi su \verb|shuffled| duomenų rinkiniu.
Tai galima paaiškinti faktu, jog GA optimizavo variantus rikiuojant atsitiktinius, dublikatų neturinčius duomenis, tad sugeneruoti variantai
geriausiai prisitaikė rikiuoti būtent tokius duomenų rinkinius.

\begin{figure}[H]
  \centering
  \includegraphics[scale=0.8]{img/cycles_1024_1024.jpg}
  \caption{Veikimo laikas priklausomai nuo duomenų rinkinio su $N = 1024$}
  \label{img:cycles_1024_1024}
\end{figure}

\pagebreak

\subsubsection{Palyginimai}

Vertinant \ref{img:comparisons_1024_1024} pav. pateikiamus atliekamų palyginimų rezultatus, pastebimos panašios tendencijos,
kaip ir analizuojant veikimo laiko rezultatus - mažiausiai palankus yra \verb|shuffled| duomenų rinkinys, labiausiai palankus yra \verb|push_min| duomenų rinkinys.

Taip pat galima pastebėti, jog rinkinys \verb|descending| yra palankesnis veikimo laikui, nei būtų galima tikėtis vertinant atliekamus palyginimus.
Nors rikiuojant šį duomenų rinkinį reikia atlikti gana daug operacijų, jis yra lengvai nuspėjamas,
kadangi visi elementai yra išrikiuoti (nors ir nepalankia tvarka).
Tad beveik visada galima spėti, jog elementas ties pozicija $i$ yra mažesnis už elementą esantį ties pozicija $i - h$
ir atliekant tokius spėjimus neatspėtų šakų skaičius turėtų būti santykinai žemas.

Taip pat galima pastebėti, jog genetinio algoritmo sugeneruoti Šelo algoritmo variantai su duomenų rinkiniais \verb|shuffled|, \verb|shuffled_mod_sqrt|, \verb|descending|
atlieka ženkliai daugiau palyginimo operacijų, nei literatūroje pateikti variantai.
Iš esmės to buvo galima tikėtis, kadangi gautų variantų veikimo laikas buvo patobulintas paaukojant atliekamų operacijų kiekį.
Tačiau su likusiais duomenų rinkiniais šie variantai atlieka pastebimai mažiau palyginimo operacijų.
Tai galima paaiškinti tuo, jog sugeneruoti variantai turi mažiau perėjimų, nei literatūroje pateikti variantai.
Todėl kai duomenys yra dalinai išrikiuoti, šie algoritmai atlieka mažiau nereikalingų palyginimų, nei literatūroje pateikti variantai. 

\begin{figure}[H]
  \centering
  \includegraphics[scale=0.8]{img/comparisons_1024_1024.jpg}
  \caption{Atliekami palyginimai priklausomai nuo duomenų rinkinio su $N = 1024$}
  \label{img:comparisons_1024_1024}
\end{figure}

\pagebreak

\subsubsection{Priskyrimai}

\ref{img:assignments_1024_1024} pav. pateikiami atliekamų priskyrimų rezultatai.
Kaip ir vertinant atliekamus palyginimus, nepalankiausias yra duomenų rinkinys \verb|shuffled|, labiausiai palankus - rinkinys \verb|push_min|.

Genetinio algoritmo pagalba gauti Šelo algoritmo variantai, kaip ir analizuojant atliekamus palyginimus,
su duomenų rinkiniais \verb|shuffled|, \verb|shuffled_mod_sqrt|, \verb|descending| atlieka ženkliai daugiau priskyrimo operacijų, nei literatūroje pateikti variantai.
Tiesa, su duomenų rinkiniais \verb|partially_sorted| ir \verb|merge| atliekamų priskyrimų rezultatai yra kiek palankesni,
o su duomenų rinkiniu \verb|push_min|
sugeneruoti variantai lenkia literatūroje pateikiamus variantus.

% TODO: truksta teksto cia

\begin{figure}[H]
  \centering
  \includegraphics[scale=0.8]{img/assignments_1024_1024.jpg}
  \caption{Atliekami priskyrimai priklausomai nuo duomenų rinkinio su $N = 1024$}
  \label{img:assignments_1024_1024}
\end{figure}

\pagebreak

\subsection{Efektyvumas priklausomai nuo duomenų dydžio}

\subsubsection{Veikimo laikas}

\ref{img:push_min_cycles_128} pav. pateikiami veikimo laiko rezultatai su duomenų rinkiniu \verb|push_min| ir nedideliais duomenų dydžiais.
Galima pastebėti, jog augant duomenų dydžiui sugeneruotų algoritmų veikimo laikas beveik nesikeičia, tuo tarpu literatūroje pateikti variantai
su mažiausiu duomenų dydžiu veikia daugiau nei 2 kartus lėčiau, augant duomenų dydžiui veikimo laikas gerėja.
Tai galima paaiškinti tuo, jog sugeneruoti algoritmai su $N = 32$ atliks vos du perėjimus, tuo tarpu literatūroje pateikiami variantai atliks 4.
Didžiausią įtaką veikimo laikui šiuo atveju turi mažiausi tarpai, kadangi su didesniais tarpais yra atliekama mažiau iteracijų.
Kadangi šis duomenų rinkinys yra beveik išrikiuotas, papildomi du perėjimai šiuo atveju pastebimai sulėtina veikimą.

\begin{figure}[H]
  \centering
  \includegraphics[scale=0.8]{img/push_min_cycles_128.jpg}
  \caption{Veikimo laikas su duomenų rinkiniu push\_min ir $N \leq 128$}
  \label{img:push_min_cycles_128}
\end{figure}

\ref{img:shuffled_cycles_128} pav. pateikiami veikimo laiko rezultatai su duomenų rinkiniu \verb|shuffled| ir nedideliais duomenų dydžiais.
Galima pastebėti, jog sugeneruotų ir literatūroje pateikiamų variantų rezultatai šiuo atveju skiriasi mažiau.
Tai paaiškina \verb|shuffled| duomenų rinkinio specifika - kadangi duomenys yra atsitiktiniai, tenka atlikti žymiai daugiau elementų perstūmimų,
tad didesnis naudojamų tarpų kiekis nesukelia problemų. 
Ir toliau galima pastebėti tendenciją, jog su nedideliais duomenų dydžiais literatūroje pateikiamų variantų veikimo laikas gerėja augant duomenų dydžiui.
Sugeneruoti algoritmai su visais pateikiamais duomenų dydžiais lenkia literatūroje pateikiamus variantus.
Iš esmės tai galima paaiškinti tuo, jog sugeneruoti algoritmai naudoja mažiau perėjimų, jų santykinis tarpų atstumas yra didesnis,
tad su visais duomenų dydžiais daugiau rikiavimo jie atlieka naudodami rikiavimą įterpimu, kuris veikia
greičiau nei Šelo algoritmas nedideliems duomenų dydžiams. % TODO: citata?

\begin{figure}[H]
  \centering
  \includegraphics[scale=0.8]{img/shuffled_cycles_128.jpg}
  \caption{Veikimo laikas su duomenų rinkiniu shuffled ir $N \leq 128$}
  \label{img:shuffled_cycles_128}
\end{figure}

\ref{img:shuffled_cycles_8192} pav. yra pateikiami veikimo laiko rezultatai su duomenų rinkiniu \verb|shuffled| ir dideliais duomenų dydžiais.
Šiuo atveju galima pastebėti, jog literatūroje pateikiamų variantų veikimo laikas nežymiai didėja augant duomenų dydžiui.
Tuo tarpu sugeneruotų algoritmų C2 ir C3 veikimo laikas išlieka pakankamai stabilus, net ir augant duomenų dydžiui, taip pat
bene geriausi rezultatai pastebimi su didžiausiu duomenų dydžiu.
Tiesa, algoritmo C1 rezultatai yra artimesni literatūroje pateikiamiems variantams,
kas yra pakankamai netikėta, kadangi jis yra labai panašus į algoritmą C2 (skiriasi tik du priešpaskutiniai perėjimai).
Tad galima daryti išvadą, jog perėjimai su didesniais tarpais rikiuojant pakankamai didelius duomenų dydžius turi gana didelę įtaką duoto varianto efektyvumui.

\begin{figure}[H]
  \centering
  \includegraphics[scale=0.8]{img/shuffled_cycles_8192.jpg}
  \caption{Veikimo laikas su duomenų rinkiniu shuffled ir $N \leq 8192$}
  \label{img:shuffled_cycles_8192}
\end{figure}

\pagebreak

\subsubsection{Palyginimai}

\ref{img:shuffled_comparisons_128} pav. yra pateikiami atliekami palyginimai su duomenų rinkiniu \verb|shuffled| ir nedideliais duomenų dydžiais.
Galima pastebėti, jog sugeneruotų variantų atliekamų palyginimų skaičius didėjant duomenų dydžiui gana sparčiai auga.
Literatūrinių variantų atliekamų palyginimų skaičius auga nuosaikiau.
Su $N = 32$ sugeneruotų variantų atliekamų palyginimų skaičius yra pakankamai mažas ir nedaug atsilieka nuo literatūrinių variantų.
Tai galima paaiškinti tuo, šie variantai naudoja mažiau tarpų ir daugiau rikiavimo atlieka su tarpu $1$,
o rikiavimas įterpimu yra pakankamai efektyvus atliekamų palyginimų prasme, kai duomenų dydis yra pakankamai mažas.
Tačiau mažesnis perėjimų kiekis sukelia sunkumų su didesniais duomenų dydžiais ir duomenų dydžiui augant sugeneruoti variantai atlieka vis daugiau palyginimų.

\begin{figure}[H]
  \centering
  \includegraphics[scale=0.8]{img/shuffled_comparisons_128.jpg}
  \caption{Palyginimai su duomenų rinkiniu shuffled ir $N \leq 128$}
  \label{img:shuffled_comparisons_128}
\end{figure}


\ref{img:descending_comparisons_128} pav. yra pateikiami atliekami palyginimai su duomenų rinkiniu \verb|descending| ir nedideliais duomenų dydžiais.
Šiuo atveju literatūrinų variantų rezultatai yra gana stabilūs ir auga nežymiai didėjant duomenų dydžiui.
Tuo tarpu sugeneruoti variantai veikia mažiau stabiliai, galima pastebėti nereguliarius rezultatus priklausomai nuo duomenų dydžio:
su $N = 32$ pastebimi apytiksliai 30\% prastesni A3 varianto rezultatai lyginant su geriausius rezultatus pateikusiu variantu (Sedgewick),
su $N = 64$ pastebimas didelis A2 varianto atliekamų palyginimų šuolis,
o su $N = 128$ pastebimas gana didelis A1 varianto skirtumas nuo geriausio rezultato.
Tai galima paaiškinti tuo, jog sugeneruoti variantai naudoja ganėtinai mažai tarpų, ir pasitaikius nepalankiam duomenų rinkiniui ir/ar dydžiui,
šių variantų efektyvumas gali būti stipriau paveiktas, kadangi papildomi tarpai duoda tam tikrą garantiją, jog blogiausias atvejis nebus ypač prastas.
Kaip pavyzdį galima pateikti Pratt tarpų seką \cite{pratt1972shellsort}, kuri naudoja labai daug tarpų, tad praktikoje nėra efektyvi, tačiau
šiuo metu yra geriausia žinoma seka pagal laiko sudėtingumą blogiausiu atveju.

\begin{figure}[H]
  \centering
  \includegraphics[scale=0.8]{img/descending_comparisons_128.jpg}
  \caption{Palyginimai su duomenų rinkiniu descending ir $N \leq 128$}
  \label{img:descending_comparisons_128}
\end{figure}

\ref{img:shuffled_comparisons_8192} pav. yra pateikiami atliekami palyginimai su duomenų rinkiniu \verb|shuffled| ir dideliais duomenų dydžiais.
Galima pastebėti, jog sugeneruotų variantų rezultatai su duomenų dydžiais $2048$ ir $4096$ yra pakankamai geri ir nežymiai atsilieka nuo literatūrinių variantų.
Tiesa, su didžiausiu tiriamu duomenų dydžiu atliekamų palyginimų rezultatai yra prastesni, tačiau veikimo laiko rezultatai su šiuo duomenų dydžiu buvo pastebimai geresni.
Tad iš esmės pastebimas sugeneruotų variantų daromas kompromisas, kur atliekamų operacijų skaičius paaukojamas vardan palankesnio veikimo laiko.

\begin{figure}[H]
  \centering
  \includegraphics[scale=0.8]{img/shuffled_comparisons_8192.jpg}
  \caption{Palyginimai su duomenų rinkiniu shuffled ir $N \leq 8192$}
  \label{img:shuffled_comparisons_8192}
\end{figure}

\pagebreak

\subsubsection{Priskyrimai}

Bendrai atliekamų priskyrimų rezultatai yra gana panašūs į atliekamų palyginimų, nors yra pastebima skirtumų.
To pavyzdys yra \ref{img:shuffled_assignments_8192} pav. esantys priskyrimų rezultatai su duomenų rinkiniu \verb|shuffled| ir dideliais duomenų dydžiais.
Šiuo atveju variantas C1, kuris su tirtais duomenų dydžiais atliko daugiausia palyginimų, iš sugeneruotų variantų atliko mažiausiai priskyrimų.
Labiausiai tikėtina, jog generavimo metu žemas priskyrimų skaičius atsvėrė kitus kriterijus ir taip sumažino varianto bendrą kainą.    

\begin{figure}[H]
  \centering
  \includegraphics[scale=0.7]{img/shuffled_assignments_8192.jpg}
  \caption{Priskyrimai su duomenų rinkiniu shuffled ir $N \leq 8192$}
  \label{img:shuffled_assignments_8192}
\end{figure}

Taip pat skirtumai pastebimi su \verb|descending| duomenų rinkiniu ir dideliais duomenų dydžiais (\ref{img:descending_assignments_8192} pav.).
Šiuo atveju varianto C3 atliekamų priskyrimų skaičius vis auga ir ties $N = 8192$ nuo geriausio rezultato skiriasi apytiksliai 30\%.
Kadangi variantas C3 turi 2 perėjimais mažiau nei variantai C1 ir C2 ir didžiausi jo tarpai yra santykinai nedideli,
galima pastebėti naudojamų perėjimų skaičiaus ir didesnių tarpų įtaką efektyvumui kai duomenų rinkinys yra nepalankus.

\begin{figure}[H]
  \centering
  \includegraphics[scale=0.7]{img/descending_assignments_8192.jpg}
  \caption{Priskyrimai su duomenų rinkiniu shuffled ir $N \leq 8192$}
  \label{img:descending_assignments_8192}
\end{figure}

\sectionnonum{Išvados}
% magic 3: rezultatai, prognoze, argumentas (gavom ta, todel ateityje bus taip, nes...)
% Išvadose ir pasiūlymuose, nekartojant atskirų dalių apibendrinimų,
% suformuluojamos svarbiausios darbo išvados, rekomendacijos bei pasiūlymai.

\sectionnonum{Conclusions}
% Šiame skyriuje pateikiamos išvados (reziume) anglų kalba.


\printbibliography[heading=bibintoc]

\appendix  % Priedai

\section{Eksperimentams naudota Šelo algoritmo implementacija}

\begin{lstlisting}[label={alg:test_shellsort},language=C++]
template <typename T>
inline void test_shellsort(T & data) {
    const int gaps[] = { 1 };
    const int size = data.size();

    for (int gap: gaps) {
        for (int i = gap; i < size; i++) {
            if (data[i - gap] > data[i]) {
                auto temp = data[i];
                int j = i;

                do {
                    data[j] = data[j - gap];
                    j -= gap;
                } while (j >= gap && data[j - gap] > temp);

                data[j] = temp;
            }
        }
    }
}
\end{lstlisting}


\end{document}
